<pre class="highlight"><span class="c1"># not required by the main lib.</span>
<span class="c1"># to use this module, require &#39;rouge/cli&#39;.</span>

<span class="c1"># stdlib</span>
<span class="nb">require</span> <span class="s1">&#39;optparse&#39;</span>

<span class="c1"># gems</span>
<span class="nb">require</span> <span class="s1">&#39;thor&#39;</span>

<span class="c1"># to use this module, require &#39;rouge/cli&#39;.</span>

<span class="c1"># stdlib</span>
<span class="nb">require</span> <span class="s1">&#39;optparse&#39;</span>

<span class="c1"># gems</span>
<span class="nb">require</span> <span class="s1">&#39;thor&#39;</span>

<span class="c1"># to use this module, require &#39;rouge/cli&#39;.</span>

<span class="c1"># stdlib</span>
<span class="nb">require</span> <span class="s1">&#39;optparse&#39;</span>

<span class="c1"># gems</span>
<span class="nb">require</span> <span class="s1">&#39;thor&#39;</span>

<span class="c1"># to use this module, require &#39;rouge/cli&#39;.</span>

<span class="c1"># stdlib</span>
<span class="nb">require</span> <span class="s1">&#39;optparse&#39;</span>

<span class="c1"># gems</span>
<span class="nb">require</span> <span class="s1">&#39;thor&#39;</span>

<span class="c1"># to use this module, require &#39;rouge/cli&#39;.</span>

<span class="c1"># stdlib</span>
<span class="nb">require</span> <span class="s1">&#39;optparse&#39;</span>

<span class="c1"># gems</span>
<span class="nb">require</span> <span class="s1">&#39;thor&#39;</span>

<span class="c1"># to use this module, require &#39;rouge/cli&#39;.</span>

<span class="c1"># stdlib</span>
<span class="nb">require</span> <span class="s1">&#39;optparse&#39;</span>

<span class="c1"># gems</span>
<span class="nb">require</span> <span class="s1">&#39;thor&#39;</span>

<span class="c1"># to use this module, require &#39;rouge/cli&#39;.</span>

<span class="c1"># stdlib</span>
<span class="nb">require</span> <span class="s1">&#39;optparse&#39;</span>

<span class="c1"># gems</span>
<span class="nb">require</span> <span class="s1">&#39;thor&#39;</span>

<span class="c1"># to use this module, require &#39;rouge/cli&#39;.</span>

<span class="c1"># stdlib</span>
<span class="nb">require</span> <span class="s1">&#39;optparse&#39;</span>

<span class="c1"># gems</span>
<span class="nb">require</span> <span class="s1">&#39;thor&#39;</span>

<span class="c1"># to use this module, require &#39;rouge/cli&#39;.</span>

<span class="c1"># stdlib</span>
<span class="nb">require</span> <span class="s1">&#39;optparse&#39;</span>

<span class="c1"># gems</span>
<span class="nb">require</span> <span class="s1">&#39;thor&#39;</span>

<span class="c1"># to use this module, require &#39;rouge/cli&#39;.</span>

<span class="c1"># stdlib</span>
<span class="nb">require</span> <span class="s1">&#39;optparse&#39;</span>

<span class="c1"># gems</span>
<span class="nb">require</span> <span class="s1">&#39;thor&#39;</span>

<span class="c1"># to use this module, require &#39;rouge/cli&#39;.</span>

<span class="c1"># stdlib</span>
<span class="nb">require</span> <span class="s1">&#39;optparse&#39;</span>

<span class="c1"># gems</span>
<span class="nb">require</span> <span class="s1">&#39;thor&#39;</span>

<span class="c1"># to use this module, require &#39;rouge/cli&#39;.</span>

<span class="c1"># stdlib</span>
<span class="nb">require</span> <span class="s1">&#39;optparse&#39;</span>

<span class="c1"># gems</span>
<span class="nb">require</span> <span class="s1">&#39;thor&#39;</span>

<span class="k">module</span> <span class="nn">Rouge</span>
  <span class="k">class </span><span class="nc">CLI</span> <span class="o">&lt;</span> <span class="no">Thor</span>
    <span class="n">default_task</span> <span class="ss">:highlight</span>

    <span class="k">def </span><span class="nc">self</span><span class="o">.</span><span class="nf">start</span><span class="p">(</span><span class="n">argv</span><span class="o">=</span><span class="no">ARGV</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">argv</span><span class="nf">.include?</span> <span class="s1">&#39;-v&#39;</span> <span class="n">or</span> <span class="n">argv</span><span class="nf">.include?</span> <span class="s1">&#39;--version&#39;</span>
        <span class="nb">puts</span> <span class="no">Rouge</span><span class="nf">.version</span>
        <span class="nb">exit</span> <span class="mi">0</span>
      <span class="k">end</span>

      <span class="k">unless</span> <span class="sx">%w(highlight style list --help -h help)</span><span class="nf">.include?</span><span class="p">(</span><span class="n">argv</span><span class="nf">.first</span><span class="p">)</span>
        <span class="n">argv</span><span class="nf">.unshift</span> <span class="s1">&#39;highlight&#39;</span>
      <span class="k">end</span>

      <span class="k">super</span><span class="p">(</span><span class="n">argv</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="n">desc</span> <span class="s1">&#39;highlight [FILE]&#39;</span><span class="p">,</span> <span class="s1">&#39;highlight some code&#39;</span>
    <span class="n">option</span> <span class="ss">:input_file</span><span class="p">,</span> <span class="ss">:aliases</span> <span class="o">=&gt;</span> <span class="s1">&#39;-i&#39;</span><span class="p">,</span>  <span class="ss">:desc</span> <span class="o">=&gt;</span> <span class="s1">&#39;the file to operate on&#39;</span>
    <span class="n">option</span> <span class="ss">:lexer</span><span class="p">,</span> <span class="ss">:aliases</span> <span class="o">=&gt;</span> <span class="s1">&#39;-l&#39;</span><span class="p">,</span>
      <span class="ss">:desc</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="s1">&#39;Which lexer to use.  If not provided, rougify will try to &#39;</span> <span class="o">+</span>
                <span class="s1">&#39;guess based on --mimetype, the filename, and the file &#39;</span> <span class="o">+</span>
                <span class="s1">&#39;contents.&#39;</span><span class="p">)</span>
    <span class="n">option</span> <span class="ss">:formatter</span><span class="p">,</span> <span class="ss">:aliases</span> <span class="o">=&gt;</span> <span class="s1">&#39;-f&#39;</span><span class="p">,</span> <span class="ss">:default</span> <span class="o">=&gt;</span> <span class="s1">&#39;terminal256&#39;</span><span class="p">,</span>
      <span class="ss">:desc</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="s1">&#39;Which formatter to use.&#39;</span><span class="p">)</span>
    <span class="n">option</span> <span class="ss">:mimetype</span><span class="p">,</span> <span class="ss">:aliases</span> <span class="o">=&gt;</span> <span class="s1">&#39;-m&#39;</span><span class="p">,</span>
      <span class="ss">:desc</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="s1">&#39;a mimetype that Rouge will use to guess the correct lexer. &#39;</span> <span class="o">+</span>
                <span class="s1">&#39;This is ignored if --lexer is specified.&#39;</span><span class="p">)</span>
    <span class="n">option</span> <span class="ss">:lexer_opts</span><span class="p">,</span> <span class="ss">:aliases</span> <span class="o">=&gt;</span> <span class="s1">&#39;-L&#39;</span><span class="p">,</span> <span class="ss">:type</span> <span class="o">=&gt;</span> <span class="ss">:hash</span><span class="p">,</span> <span class="ss">:default</span> <span class="o">=&gt;</span> <span class="p">{},</span>
      <span class="ss">:desc</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="s1">&#39;a hash of options to pass to the lexer.&#39;</span><span class="p">)</span>
    <span class="n">option</span> <span class="ss">:formatter_opts</span><span class="p">,</span> <span class="ss">:aliases</span> <span class="o">=&gt;</span> <span class="s1">&#39;-F&#39;</span><span class="p">,</span> <span class="ss">:type</span> <span class="o">=&gt;</span> <span class="ss">:hash</span><span class="p">,</span> <span class="ss">:default</span> <span class="o">=&gt;</span> <span class="p">{},</span>
      <span class="ss">:desc</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="s1">&#39;a hash of options to pass to the formatter.&#39;</span><span class="p">)</span>
    <span class="k">def </span><span class="nf">highlight</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="kp">nil</span><span class="p">)</span>
      <span class="n">filename</span> <span class="o">=</span> <span class="n">options</span><span class="o">[</span><span class="ss">:file</span><span class="o">]</span> <span class="o">||</span> <span class="n">file</span>
      <span class="n">source</span> <span class="o">=</span> <span class="n">filename</span> <span class="p">?</span> <span class="no">File</span><span class="nf">.read</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="p">:</span> <span class="vg">$stdin</span><span class="nf">.read</span>

      <span class="k">if</span> <span class="n">options</span><span class="o">[</span><span class="ss">:lexer</span><span class="o">]</span><span class="nf">.nil?</span>
        <span class="n">lexer_class</span> <span class="o">=</span> <span class="no">Lexer</span><span class="nf">.guess</span><span class="p">(</span>
          <span class="ss">:filename</span> <span class="o">=&gt;</span> <span class="n">filename</span><span class="p">,</span>
          <span class="ss">:mimetype</span> <span class="o">=&gt;</span> <span class="n">options</span><span class="o">[</span><span class="ss">:mimetype</span><span class="o">]</span><span class="p">,</span>
          <span class="ss">:source</span>   <span class="o">=&gt;</span> <span class="n">source</span><span class="p">,</span>
        <span class="p">)</span>
      <span class="k">else</span>
        <span class="n">lexer_class</span> <span class="o">=</span> <span class="no">Lexer</span><span class="nf">.find</span><span class="p">(</span><span class="n">options</span><span class="o">[</span><span class="ss">:lexer</span><span class="o">]</span><span class="p">)</span>
        <span class="k">raise</span> <span class="s2">&quot;unknown lexer: </span><span class="si">#{</span><span class="n">options</span><span class="o">[</span><span class="ss">:lexer</span><span class="o">]</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">unless</span> <span class="n">lexer_class</span>
      <span class="k">end</span>

      <span class="n">formatter_class</span> <span class="o">=</span> <span class="no">Formatter</span><span class="nf">.find</span><span class="p">(</span><span class="n">options</span><span class="o">[</span><span class="ss">:formatter</span><span class="o">]</span><span class="p">)</span>

      <span class="c1"># only HTML is supported for now</span>
      <span class="n">formatter</span> <span class="o">=</span> <span class="n">formatter_class</span><span class="nf">.new</span><span class="p">(</span><span class="n">normalize_hash_keys</span><span class="p">(</span><span class="n">options</span><span class="o">[</span><span class="ss">:formatter_opts</span><span class="o">]</span><span class="p">))</span>
      <span class="n">lexer</span> <span class="o">=</span> <span class="n">lexer_class</span><span class="nf">.new</span><span class="p">(</span><span class="n">normalize_hash_keys</span><span class="p">(</span><span class="n">options</span><span class="o">[</span><span class="ss">:lexer_opts</span><span class="o">]</span><span class="p">))</span>

      <span class="nb">puts</span> <span class="no">Rouge</span><span class="nf">.highlight</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">lexer</span><span class="p">,</span> <span class="n">formatter</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="n">desc</span> <span class="s1">&#39;style THEME&#39;</span><span class="p">,</span> <span class="s1">&#39;render THEME as css&#39;</span>
    <span class="n">option</span> <span class="ss">:scope</span><span class="p">,</span> <span class="ss">:desc</span> <span class="o">=&gt;</span> <span class="s2">&quot;a css selector to scope the styles to&quot;</span>
    <span class="k">def </span><span class="nf">style</span><span class="p">(</span><span class="n">theme_name</span><span class="o">=</span><span class="s1">&#39;thankful_eyes&#39;</span><span class="p">)</span>
      <span class="n">theme</span> <span class="o">=</span> <span class="no">Theme</span><span class="nf">.find</span><span class="p">(</span><span class="n">theme_name</span><span class="p">)</span>
      <span class="k">raise</span> <span class="s2">&quot;unknown theme: </span><span class="si">#{</span><span class="n">theme_name</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">unless</span> <span class="n">theme</span>

      <span class="nb">puts</span> <span class="n">theme</span><span class="nf">.new</span><span class="p">(</span><span class="n">options</span><span class="p">)</span><span class="nf">.render</span>
    <span class="k">end</span>

    <span class="n">desc</span> <span class="s1">&#39;list&#39;</span><span class="p">,</span> <span class="s1">&#39;list the available lexers, formatters, and styles&#39;</span>
    <span class="k">def </span><span class="nf">list</span>
      <span class="nb">puts</span> <span class="s2">&quot;== Available Lexers ==&quot;</span>
      <span class="n">all_lexers</span> <span class="o">=</span> <span class="no">Lexer</span><span class="nf">.all</span>
      <span class="n">max_len</span> <span class="o">=</span> <span class="n">all_lexers</span><span class="nf">.map</span> <span class="p">{</span> <span class="o">|</span><span class="n">l</span><span class="o">|</span> <span class="n">l</span><span class="nf">.tag.size</span> <span class="p">}</span><span class="nf">.max</span>

      <span class="no">Lexer</span><span class="nf">.all.each</span> <span class="k">do</span> <span class="o">|</span><span class="n">lexer</span><span class="o">|</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">lexer</span><span class="nf">.desc</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">lexer</span><span class="nf">.aliases.any?</span>
          <span class="n">desc</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot; [aliases: </span><span class="si">#{</span><span class="n">lexer</span><span class="nf">.aliases.join</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">]&quot;</span>
        <span class="k">end</span>
        <span class="nb">puts</span> <span class="s2">&quot;%s: %s&quot;</span> <span class="o">%</span> <span class="o">[</span><span class="n">lexer</span><span class="nf">.tag</span><span class="p">,</span> <span class="n">desc</span><span class="o">]</span>
        <span class="nb">puts</span>
      <span class="k">end</span>
    <span class="k">end</span>

  <span class="kp">private</span>
    <span class="c1"># TODO: does Thor do this for me?</span>
    <span class="k">def </span><span class="nf">normalize_hash_keys</span><span class="p">(</span><span class="nb">hash</span><span class="p">)</span>
      <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
      <span class="nb">hash</span><span class="nf">.each</span> <span class="k">do</span> <span class="o">|</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="o">|</span>
        <span class="n">new_key</span> <span class="o">=</span> <span class="n">k</span><span class="nf">.tr</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span><span class="nf">.to_sym</span>
        <span class="n">out</span><span class="o">[</span><span class="n">new_key</span><span class="o">]</span> <span class="o">=</span> <span class="n">v</span>
      <span class="k">end</span>

      <span class="n">out</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="k">module</span> <span class="nn">Rouge</span>
  <span class="c1"># A Formatter takes a token stream and formats it for human viewing.</span>
  <span class="k">class </span><span class="nc">Formatter</span>
    <span class="c1"># @private</span>
    <span class="no">REGISTRY</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Specify or get the unique tag for this formatter.  This is used</span>
    <span class="c1"># for specifying a formatter in `rougify`.</span>
    <span class="k">def </span><span class="nc">self</span><span class="o">.</span><span class="nf">tag</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="kp">nil</span><span class="p">)</span>
      <span class="k">return</span> <span class="vi">@tag</span> <span class="k">unless</span> <span class="n">tag</span>
      <span class="no">REGISTRY</span><span class="o">[</span><span class="n">tag</span><span class="o">]</span> <span class="o">=</span> <span class="nb">self</span>

      <span class="vi">@tag</span> <span class="o">=</span> <span class="n">tag</span>
    <span class="k">end</span>

    <span class="c1"># Find a formatter class given a unique tag.</span>
    <span class="k">def </span><span class="nc">self</span><span class="o">.</span><span class="nf">find</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
      <span class="no">REGISTRY</span><span class="o">[</span><span class="n">tag</span><span class="o">]</span>
    <span class="k">end</span>

    <span class="c1"># Format a token stream.  Delegates to {#format}.</span>
    <span class="k">def </span><span class="nc">self</span><span class="o">.</span><span class="nf">format</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="n">opts</span><span class="o">=</span><span class="p">{})</span>
      <span class="kp">new</span><span class="p">(</span><span class="n">opts</span><span class="p">)</span><span class="nf">.format</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="c1"># Format a token stream.</span>
    <span class="k">def </span><span class="nf">format</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
      <span class="n">enum_for</span><span class="p">(</span><span class="ss">:stream</span><span class="p">,</span> <span class="n">tokens</span><span class="p">)</span><span class="nf">.to_a.join</span>
    <span class="k">end</span>

    <span class="c1"># @deprecated Use {#format} instead.</span>
    <span class="k">def </span><span class="nf">render</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
      <span class="nb">warn</span> <span class="s1">&#39;Formatter#render is deprecated, use #format instead.&#39;</span>
      <span class="nb">format</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="c1"># @abstract</span>
    <span class="c1"># yield strings that, when concatenated, form the formatted output</span>
    <span class="k">def </span><span class="nf">stream</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
      <span class="k">raise</span> <span class="s1">&#39;abstract&#39;</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="c1"># stdlib</span>
<span class="nb">require</span> <span class="s1">&#39;cgi&#39;</span>

<span class="k">module</span> <span class="nn">Rouge</span>
  <span class="k">module</span> <span class="nn">Formatters</span>
    <span class="c1"># Transforms a token stream into HTML output.</span>
    <span class="k">class </span><span class="nc">HTML</span> <span class="o">&lt;</span> <span class="no">Formatter</span>
      <span class="n">tag</span> <span class="s1">&#39;html&#39;</span>

      <span class="c1"># @option opts :css_class</span>
      <span class="c1"># A css class to be used for the generated &lt;pre&gt; tag.</span>
      <span class="k">def </span><span class="nf">initialize</span><span class="p">(</span><span class="n">opts</span><span class="o">=</span><span class="p">{})</span>
        <span class="vi">@css_class</span> <span class="o">=</span> <span class="n">opts</span><span class="o">[</span><span class="ss">:css_class</span><span class="o">]</span> <span class="o">||</span> <span class="s1">&#39;highlight&#39;</span>
        <span class="vi">@line_numbers</span> <span class="o">=</span> <span class="n">opts</span><span class="nf">.fetch</span><span class="p">(</span><span class="ss">:line_numbers</span><span class="p">)</span> <span class="p">{</span> <span class="kp">false</span> <span class="p">}</span>
      <span class="k">end</span>

      <span class="c1"># @yield the html output.</span>
      <span class="k">def </span><span class="nf">stream</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="vi">@line_numbers</span>
          <span class="n">stream_tableized</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
        <span class="k">else</span>
          <span class="n">stream_untableized</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
        <span class="k">end</span>
      <span class="k">end</span>

      <span class="k">def </span><span class="nf">stream_untableized</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
        <span class="k">yield</span> <span class="s2">&quot;&lt;pre class=</span><span class="si">#{</span><span class="vi">@css_class</span><span class="nf">.inspect</span><span class="si">}</span><span class="s2">&gt;&quot;</span>
        <span class="n">tokens</span><span class="nf">.each</span> <span class="k">do</span> <span class="o">|</span><span class="n">tok</span><span class="p">,</span> <span class="n">val</span><span class="o">|</span>
          <span class="n">span</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
        <span class="k">end</span>
        <span class="k">yield</span> <span class="s1">&#39;&lt;/pre&gt;&#39;</span>
      <span class="k">end</span>

      <span class="k">def </span><span class="nf">stream_tableized</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
        <span class="n">num_lines</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">code</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="n">tokens</span><span class="nf">.each</span> <span class="k">do</span> <span class="o">|</span><span class="n">tok</span><span class="p">,</span> <span class="n">val</span><span class="o">|</span>
          <span class="n">num_lines</span> <span class="o">+=</span> <span class="n">val</span><span class="nf">.scan</span><span class="p">(</span><span class="sr">/\n/</span><span class="p">)</span><span class="nf">.size</span>
          <span class="n">span</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">str</span><span class="o">|</span> <span class="n">code</span> <span class="o">&lt;&lt;</span> <span class="n">str</span> <span class="p">}</span>
        <span class="k">end</span>

        <span class="c1"># generate a string of newline-separated line numbers for the gutter</span>
        <span class="n">numbers</span> <span class="o">=</span> <span class="n">num_lines</span><span class="nf">.times.map</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
          <span class="sx">%&lt;&lt;div class=&quot;lineno&quot;&gt;#{x+1}&lt;/div&gt;&gt;</span>
        <span class="k">end</span><span class="nf">.join</span>

        <span class="k">yield</span> <span class="s2">&quot;&lt;table class=</span><span class="si">#{</span><span class="vi">@css_class</span><span class="nf">.inspect</span><span class="si">}</span><span class="s2">&gt;&lt;tbody&gt;&lt;tr&gt;&quot;</span>

        <span class="c1"># the &quot;gl&quot; class applies the style for Generic.Lineno</span>
        <span class="k">yield</span> <span class="s1">&#39;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre&gt;&#39;</span>
        <span class="k">yield</span> <span class="n">numbers</span>
        <span class="k">yield</span> <span class="s1">&#39;&lt;/pre&gt;&lt;/td&gt;&#39;</span>

        <span class="k">yield</span> <span class="s1">&#39;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&#39;</span>
        <span class="k">yield</span> <span class="n">code</span>
        <span class="k">yield</span> <span class="s1">&#39;&lt;/pre&gt;&lt;/td&gt;&#39;</span>

        <span class="k">yield</span> <span class="s1">&#39;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&#39;</span>
      <span class="k">end</span>

    <span class="kp">private</span>
      <span class="k">def </span><span class="nf">span</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
        <span class="c1"># TODO: properly html-encode val</span>
        <span class="n">val</span> <span class="o">=</span> <span class="no">CGI</span><span class="nf">.escape_html</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="k">case</span> <span class="n">tok</span><span class="nf">.shortname</span>
        <span class="k">when</span> <span class="s1">&#39;&#39;</span>
          <span class="k">yield</span> <span class="n">val</span>
        <span class="k">when</span> <span class="kp">nil</span>
          <span class="k">raise</span> <span class="s2">&quot;unknown token: </span><span class="si">#{</span><span class="n">tok</span><span class="nf">.inspect</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">else</span>
          <span class="k">yield</span> <span class="s1">&#39;&lt;span class=&#39;</span>
          <span class="k">yield</span> <span class="n">tok</span><span class="nf">.shortname.inspect</span>
          <span class="k">yield</span> <span class="s1">&#39;&gt;&#39;</span>
          <span class="k">yield</span> <span class="n">val</span>
          <span class="k">yield</span> <span class="s1">&#39;&lt;/span&gt;&#39;</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="k">module</span> <span class="nn">Rouge</span>
  <span class="k">module</span> <span class="nn">Formatters</span>
    <span class="c1"># A formatter for 256-color terminals</span>
    <span class="k">class </span><span class="nc">Terminal256</span> <span class="o">&lt;</span> <span class="no">Formatter</span>
      <span class="n">tag</span> <span class="s1">&#39;terminal256&#39;</span>

      <span class="c1"># @private</span>
      <span class="kp">attr_reader</span> <span class="ss">:theme</span>


      <span class="c1"># @option opts :theme</span>
      <span class="c1">#   (default is thankful_eyes) the theme to render with.</span>
      <span class="k">def </span><span class="nf">initialize</span><span class="p">(</span><span class="n">opts</span><span class="o">=</span><span class="p">{})</span>
        <span class="vi">@theme</span> <span class="o">=</span> <span class="n">opts</span><span class="o">[</span><span class="ss">:theme</span><span class="o">]</span> <span class="o">||</span> <span class="s1">&#39;thankful_eyes&#39;</span>
        <span class="vi">@theme</span> <span class="o">=</span> <span class="no">Theme</span><span class="nf">.find</span><span class="p">(</span><span class="vi">@theme</span><span class="p">)</span> <span class="k">if</span> <span class="vi">@theme</span><span class="nf">.is_a?</span> <span class="nb">String</span>
      <span class="k">end</span>

      <span class="k">def </span><span class="nf">stream</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
        <span class="n">tokens</span><span class="nf">.each</span> <span class="k">do</span> <span class="o">|</span><span class="n">tok</span><span class="p">,</span> <span class="n">val</span><span class="o">|</span>
          <span class="n">escape</span> <span class="o">=</span> <span class="n">escape_sequence</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span>
          <span class="k">yield</span> <span class="n">escape</span><span class="nf">.style_string</span>
          <span class="k">yield</span> <span class="n">val</span>
          <span class="k">yield</span> <span class="n">escape</span><span class="nf">.reset_string</span>
        <span class="k">end</span>
      <span class="k">end</span>

      <span class="k">class </span><span class="nc">EscapeSequence</span>
        <span class="kp">attr_reader</span> <span class="ss">:style</span>
        <span class="k">def </span><span class="nf">initialize</span><span class="p">(</span><span class="n">style</span><span class="p">)</span>
          <span class="vi">@style</span> <span class="o">=</span> <span class="n">style</span>
        <span class="k">end</span>

        <span class="k">def </span><span class="nc">self</span><span class="o">.</span><span class="nf">xterm_colors</span>
          <span class="vi">@xterm_colors</span> <span class="o">||=</span> <span class="o">[]</span><span class="nf">.tap</span> <span class="k">do</span> <span class="o">|</span><span class="n">out</span><span class="o">|</span>
            <span class="c1"># colors 0..15: 16 basic colors</span>
            <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="o">[</span><span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="o">]</span> <span class="c1"># 0</span>
            <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="o">[</span><span class="mh">0xcd</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="o">]</span> <span class="c1"># 1</span>
            <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="o">[</span><span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xcd</span><span class="p">,</span> <span class="mh">0x00</span><span class="o">]</span> <span class="c1"># 2</span>
            <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="o">[</span><span class="mh">0xcd</span><span class="p">,</span> <span class="mh">0xcd</span><span class="p">,</span> <span class="mh">0x00</span><span class="o">]</span> <span class="c1"># 3</span>
            <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="o">[</span><span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xee</span><span class="o">]</span> <span class="c1"># 4</span>
            <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="o">[</span><span class="mh">0xcd</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xcd</span><span class="o">]</span> <span class="c1"># 5</span>
            <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="o">[</span><span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xcd</span><span class="p">,</span> <span class="mh">0xcd</span><span class="o">]</span> <span class="c1"># 6</span>
            <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="o">[</span><span class="mh">0xe5</span><span class="p">,</span> <span class="mh">0xe5</span><span class="p">,</span> <span class="mh">0xe5</span><span class="o">]</span> <span class="c1"># 7</span>
            <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="o">[</span><span class="mh">0x7f</span><span class="p">,</span> <span class="mh">0x7f</span><span class="p">,</span> <span class="mh">0x7f</span><span class="o">]</span> <span class="c1"># 8</span>
            <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="o">[</span><span class="mh">0xff</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="o">]</span> <span class="c1"># 9</span>
            <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="o">[</span><span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0x00</span><span class="o">]</span> <span class="c1"># 10</span>
            <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="o">[</span><span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0x00</span><span class="o">]</span> <span class="c1"># 11</span>
            <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="o">[</span><span class="mh">0x5c</span><span class="p">,</span> <span class="mh">0x5c</span><span class="p">,</span> <span class="mh">0xff</span><span class="o">]</span> <span class="c1"># 12</span>
            <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="o">[</span><span class="mh">0xff</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xff</span><span class="o">]</span> <span class="c1"># 13</span>
            <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="o">[</span><span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="o">]</span> <span class="c1"># 14</span>
            <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="o">[</span><span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="o">]</span> <span class="c1"># 15</span>

            <span class="c1"># colors 16..232: the 6x6x6 color cube</span>
            <span class="n">valuerange</span> <span class="o">=</span> <span class="o">[</span><span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x5f</span><span class="p">,</span> <span class="mh">0x87</span><span class="p">,</span> <span class="mh">0xaf</span><span class="p">,</span> <span class="mh">0xd7</span><span class="p">,</span> <span class="mh">0xff</span><span class="o">]</span>

            <span class="mi">217</span><span class="nf">.times</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
              <span class="n">r</span> <span class="o">=</span> <span class="n">valuerange</span><span class="o">[</span><span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="mi">36</span><span class="p">)</span> <span class="o">%</span> <span class="mi">6</span><span class="o">]</span>
              <span class="n">g</span> <span class="o">=</span> <span class="n">valuerange</span><span class="o">[</span><span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="mi">6</span><span class="p">)</span> <span class="o">%</span> <span class="mi">6</span><span class="o">]</span>
              <span class="n">b</span> <span class="o">=</span> <span class="n">valuerange</span><span class="o">[</span><span class="n">i</span> <span class="o">%</span> <span class="mi">6</span><span class="o">]</span>
              <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="o">[</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="o">]</span>
            <span class="k">end</span>

            <span class="c1"># colors 233..253: grayscale</span>
            <span class="mi">1</span><span class="nf">.upto</span> <span class="mi">22</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
              <span class="n">v</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">10</span>
              <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="o">[</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="o">]</span>
            <span class="k">end</span>
          <span class="k">end</span>
        <span class="k">end</span>

        <span class="k">def </span><span class="nf">fg</span>
          <span class="k">return</span> <span class="vi">@fg</span> <span class="k">if</span> <span class="n">instance_variable_defined?</span> <span class="ss">:@fg</span>
          <span class="vi">@fg</span> <span class="o">=</span> <span class="n">style</span><span class="nf">.fg</span> <span class="o">&amp;&amp;</span> <span class="nb">self</span><span class="nf">.class.color_index</span><span class="p">(</span><span class="n">style</span><span class="nf">.fg</span><span class="p">)</span>
        <span class="k">end</span>

        <span class="k">def </span><span class="nf">bg</span>
          <span class="k">return</span> <span class="vi">@bg</span> <span class="k">if</span> <span class="n">instance_variable_defined?</span> <span class="ss">:@bg</span>
          <span class="vi">@bg</span> <span class="o">=</span> <span class="n">style</span><span class="nf">.bg</span> <span class="o">&amp;&amp;</span> <span class="nb">self</span><span class="nf">.class.color_index</span><span class="p">(</span><span class="n">style</span><span class="nf">.bg</span><span class="p">)</span>
        <span class="k">end</span>

        <span class="k">def </span><span class="nf">style_string</span>
          <span class="vi">@style_string</span> <span class="o">||=</span> <span class="k">begin</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="o">[]</span>

            <span class="n">attrs</span> <span class="o">&lt;&lt;</span> <span class="o">[</span><span class="s1">&#39;38&#39;</span><span class="p">,</span> <span class="s1">&#39;5&#39;</span><span class="p">,</span> <span class="n">fg</span><span class="nf">.to_s</span><span class="o">]</span> <span class="k">if</span> <span class="n">fg</span>
            <span class="n">attrs</span> <span class="o">&lt;&lt;</span> <span class="o">[</span><span class="s1">&#39;45&#39;</span><span class="p">,</span> <span class="s1">&#39;5&#39;</span><span class="p">,</span> <span class="n">bg</span><span class="nf">.to_s</span><span class="o">]</span> <span class="k">if</span> <span class="n">bg</span>
            <span class="n">attrs</span> <span class="o">&lt;&lt;</span> <span class="s1">&#39;01&#39;</span> <span class="k">if</span> <span class="n">style</span><span class="o">[</span><span class="ss">:bold</span><span class="o">]</span>
            <span class="n">attrs</span> <span class="o">&lt;&lt;</span> <span class="s1">&#39;04&#39;</span> <span class="k">if</span> <span class="n">style</span><span class="o">[</span><span class="ss">:italic</span><span class="o">]</span> <span class="c1"># underline, but hey, whatevs</span>
            <span class="n">escape</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span>
          <span class="k">end</span>
        <span class="k">end</span>

        <span class="k">def </span><span class="nf">reset_string</span>
          <span class="vi">@reset_string</span> <span class="o">||=</span> <span class="k">begin</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="o">[]</span>
            <span class="n">attrs</span> <span class="o">&lt;&lt;</span> <span class="s1">&#39;39&#39;</span> <span class="k">if</span> <span class="n">fg</span> <span class="c1"># fg reset</span>
            <span class="n">attrs</span> <span class="o">&lt;&lt;</span> <span class="s1">&#39;49&#39;</span> <span class="k">if</span> <span class="n">bg</span> <span class="c1"># bg reset</span>
            <span class="n">attrs</span> <span class="o">&lt;&lt;</span> <span class="s1">&#39;00&#39;</span> <span class="k">if</span> <span class="n">style</span><span class="o">[</span><span class="ss">:bold</span><span class="o">]</span> <span class="o">||</span> <span class="n">style</span><span class="o">[</span><span class="ss">:italic</span><span class="o">]</span>

            <span class="n">escape</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span>
          <span class="k">end</span>
        <span class="k">end</span>

      <span class="kp">private</span>
        <span class="k">def </span><span class="nf">escape</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span>
          <span class="k">return</span> <span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="n">attrs</span><span class="nf">.empty?</span>
          <span class="s2">&quot;</span><span class="se">\e</span><span class="s2">[</span><span class="si">#{</span><span class="n">attrs</span><span class="nf">.join</span><span class="p">(</span><span class="s1">&#39;;&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">m&quot;</span>
        <span class="k">end</span>

        <span class="k">def </span><span class="nc">self</span><span class="o">.</span><span class="nf">color_index</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
          <span class="vi">@color_index_cache</span> <span class="o">||=</span> <span class="p">{}</span>
          <span class="vi">@color_index_cache</span><span class="o">[</span><span class="n">color</span><span class="o">]</span> <span class="o">||=</span> <span class="n">closest_color</span><span class="p">(</span><span class="o">*</span><span class="n">get_rgb</span><span class="p">(</span><span class="n">color</span><span class="p">))</span>
        <span class="k">end</span>

        <span class="k">def </span><span class="nc">self</span><span class="o">.</span><span class="nf">get_rgb</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
          <span class="n">color</span> <span class="o">=</span> <span class="vg">$1</span> <span class="k">if</span> <span class="n">color</span> <span class="o">=~</span> <span class="sr">/#([0-9a-f]+)/i</span>
          <span class="n">hexes</span> <span class="o">=</span> <span class="k">case</span> <span class="n">color</span><span class="nf">.size</span>
          <span class="k">when</span> <span class="mi">3</span>
            <span class="n">color</span><span class="nf">.chars.map</span> <span class="p">{</span> <span class="o">|</span><span class="n">c</span><span class="o">|</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">c</span><span class="si">}#{</span><span class="n">c</span><span class="si">}</span><span class="s2">&quot;</span> <span class="p">}</span>
          <span class="k">when</span> <span class="mi">6</span>
            <span class="n">color</span><span class="nf">.scan</span> <span class="sr">/../</span>
          <span class="k">else</span>
            <span class="k">raise</span> <span class="s2">&quot;invalid color: </span><span class="si">#{</span><span class="n">color</span><span class="si">}</span><span class="s2">&quot;</span>
          <span class="k">end</span>

          <span class="n">hexes</span><span class="nf">.map</span> <span class="p">{</span> <span class="o">|</span><span class="n">h</span><span class="o">|</span> <span class="n">h</span><span class="nf">.to_i</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="p">}</span>
        <span class="k">end</span>

        <span class="k">def </span><span class="nc">self</span><span class="o">.</span><span class="nf">closest_color</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
          <span class="n">distance</span> <span class="o">=</span> <span class="mi">257</span> <span class="o">*</span> <span class="mi">257</span> <span class="o">*</span> <span class="mi">3</span> <span class="c1"># (max distance, from #000000 to #ffffff)</span>

          <span class="n">match</span> <span class="o">=</span> <span class="mi">0</span>

          <span class="n">xterm_colors</span><span class="nf">.each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="p">(</span><span class="n">cr</span><span class="p">,</span> <span class="n">cg</span><span class="p">,</span> <span class="n">cb</span><span class="p">),</span> <span class="n">i</span><span class="o">|</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">cr</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">g</span> <span class="o">-</span> <span class="n">cg</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">cb</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
            <span class="k">next</span> <span class="k">if</span> <span class="n">d</span> <span class="o">&gt;=</span> <span class="n">distance</span>

            <span class="n">match</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="n">d</span>
          <span class="k">end</span>

          <span class="n">match</span>
        <span class="k">end</span>
      <span class="k">end</span>

    <span class="c1"># private</span>
      <span class="k">def </span><span class="nf">escape_sequence</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
        <span class="vi">@escape_sequences</span> <span class="o">||=</span> <span class="p">{}</span>
        <span class="vi">@escape_sequences</span><span class="o">[</span><span class="n">token</span><span class="nf">.name</span><span class="o">]</span> <span class="o">||=</span>
          <span class="no">EscapeSequence</span><span class="nf">.new</span><span class="p">(</span><span class="n">get_style</span><span class="p">(</span><span class="n">token</span><span class="p">))</span>
      <span class="k">end</span>

      <span class="k">def </span><span class="nf">get_style</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">text_style</span> <span class="k">if</span> <span class="n">token</span><span class="nf">.name</span> <span class="o">==</span> <span class="s1">&#39;Text&#39;</span>

        <span class="n">theme</span><span class="nf">.get_own_style</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">||</span> <span class="n">text_style</span>
      <span class="k">end</span>

      <span class="k">def </span><span class="nf">text_style</span>
        <span class="n">style</span> <span class="o">=</span> <span class="n">theme</span><span class="nf">.get_style</span><span class="p">(</span><span class="no">Token</span><span class="o">[</span><span class="s1">&#39;Text&#39;</span><span class="o">]</span><span class="p">)</span>
        <span class="c1"># don&#39;t highlight text backgrounds</span>
        <span class="n">style</span><span class="nf">.delete</span> <span class="ss">:bg</span>
        <span class="n">style</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="c1"># stdlib</span>
<span class="nb">require</span> <span class="s1">&#39;strscan&#39;</span>

<span class="k">module</span> <span class="nn">Rouge</span>
  <span class="c1"># @abstract</span>
  <span class="c1"># A lexer transforms text into a stream of `[token, chunk]` pairs.</span>
  <span class="k">class </span><span class="nc">Lexer</span>
    <span class="k">class </span><span class="o">&lt;&lt;</span> <span class="nb">self</span>
      <span class="c1"># Lexes `stream` with the given options.  The lex is delegated to a</span>
      <span class="c1"># new instance.</span>
      <span class="c1">#</span>
      <span class="c1"># @see #lex</span>
      <span class="k">def </span><span class="nf">lex</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">opts</span><span class="o">=</span><span class="p">{},</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
        <span class="kp">new</span><span class="p">(</span><span class="n">opts</span><span class="p">)</span><span class="nf">.lex</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
      <span class="k">end</span>

      <span class="k">def </span><span class="nf">default_options</span><span class="p">(</span><span class="n">o</span><span class="o">=</span><span class="p">{})</span>
        <span class="vi">@default_options</span> <span class="o">||=</span> <span class="p">{}</span>
        <span class="vi">@default_options</span><span class="nf">.merge!</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="vi">@default_options</span>
      <span class="k">end</span>

      <span class="c1"># Given a string, return the correct lexer class.</span>
      <span class="k">def </span><span class="nf">find</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
        <span class="n">registry</span><span class="o">[</span><span class="nb">name</span><span class="nf">.to_s</span><span class="o">]</span>
      <span class="k">end</span>

      <span class="c1"># Find a lexer, with fancy shiny features.</span>
      <span class="c1">#</span>
      <span class="c1"># * The string you pass can include CGI-style options</span>
      <span class="c1">#</span>
      <span class="c1">#     Lexer.find_fancy(&#39;erb?parent=tex&#39;)</span>
      <span class="c1">#</span>
      <span class="c1"># * You can pass the special name &#39;guess&#39; so we guess for you,</span>
      <span class="c1">#   and you can pass a second argument of the code to guess by</span>
      <span class="c1">#</span>
      <span class="c1">#     Lexer.find_fancy(&#39;guess&#39;, &quot;#!/bin/bash\necho Hello, world&quot;)</span>
      <span class="c1">#</span>
      <span class="c1"># This is used in the Redcarpet plugin as well as Rouge&#39;s own</span>
      <span class="c1"># markdown lexer for highlighting internal code blocks.</span>
      <span class="c1">#</span>
      <span class="k">def </span><span class="nf">find_fancy</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">code</span><span class="o">=</span><span class="kp">nil</span><span class="p">)</span>
        <span class="nb">name</span><span class="p">,</span> <span class="n">opts</span> <span class="o">=</span> <span class="n">str</span> <span class="p">?</span> <span class="n">str</span><span class="nf">.split</span><span class="p">(</span><span class="s1">&#39;?&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="p">:</span> <span class="o">[</span><span class="kp">nil</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="o">]</span>

        <span class="c1"># parse the options hash from a cgi-style string</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="no">CGI</span><span class="nf">.parse</span><span class="p">(</span><span class="n">opts</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="nf">.map</span> <span class="k">do</span> <span class="o">|</span><span class="n">k</span><span class="p">,</span> <span class="n">vals</span><span class="o">|</span>
          <span class="o">[</span> <span class="n">k</span><span class="nf">.to_sym</span><span class="p">,</span> <span class="n">vals</span><span class="nf">.empty?</span> <span class="p">?</span> <span class="kp">true</span> <span class="p">:</span> <span class="n">vals</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">]</span>
        <span class="k">end</span>

        <span class="n">opts</span> <span class="o">=</span> <span class="no">Hash</span><span class="o">[</span><span class="n">opts</span><span class="o">]</span>

        <span class="n">lexer_class</span> <span class="o">=</span> <span class="k">case</span> <span class="nb">name</span>
        <span class="k">when</span> <span class="s1">&#39;guess&#39;</span><span class="p">,</span> <span class="kp">nil</span>
          <span class="nb">self</span><span class="nf">.guess</span><span class="p">(</span><span class="ss">:source</span> <span class="o">=&gt;</span> <span class="n">code</span><span class="p">,</span> <span class="ss">:mimetype</span> <span class="o">=&gt;</span> <span class="n">opts</span><span class="o">[</span><span class="ss">:mimetype</span><span class="o">]</span><span class="p">)</span>
        <span class="k">when</span> <span class="nb">String</span>
          <span class="nb">self</span><span class="nf">.find</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
        <span class="k">end</span>

        <span class="n">lexer_class</span> <span class="o">&amp;&amp;</span> <span class="n">lexer_class</span><span class="nf">.new</span><span class="p">(</span><span class="n">opts</span><span class="p">)</span>
      <span class="k">end</span>

      <span class="c1"># Specify or get this lexer&#39;s description.</span>
      <span class="k">def </span><span class="nf">desc</span><span class="p">(</span><span class="n">arg</span><span class="o">=</span><span class="ss">:absent</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">arg</span> <span class="o">==</span> <span class="ss">:absent</span>
          <span class="vi">@desc</span>
        <span class="k">else</span>
          <span class="vi">@desc</span> <span class="o">=</span> <span class="n">arg</span>
        <span class="k">end</span>
      <span class="k">end</span>

      <span class="c1"># Specify or get the path name containing a small demo for</span>
      <span class="c1"># this lexer (can be overriden by {demo}).</span>
      <span class="k">def </span><span class="nf">demo_file</span><span class="p">(</span><span class="n">arg</span><span class="o">=</span><span class="ss">:absent</span><span class="p">)</span>
        <span class="k">return</span> <span class="vi">@demo_file</span> <span class="o">=</span> <span class="no">Pathname</span><span class="nf">.new</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">unless</span> <span class="n">arg</span> <span class="o">==</span> <span class="ss">:absent</span>

        <span class="vi">@demo_file</span> <span class="o">=</span> <span class="no">Pathname</span><span class="nf">.new</span><span class="p">(</span><span class="kp">__FILE__</span><span class="p">)</span><span class="nf">.dirname.join</span><span class="p">(</span><span class="s1">&#39;demos&#39;</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span>
      <span class="k">end</span>

      <span class="c1"># Specify or get a small demo string for this lexer</span>
      <span class="k">def </span><span class="nf">demo</span><span class="p">(</span><span class="n">arg</span><span class="o">=</span><span class="ss">:absent</span><span class="p">)</span>
        <span class="k">return</span> <span class="vi">@demo</span> <span class="o">=</span> <span class="n">arg</span> <span class="k">unless</span> <span class="n">arg</span> <span class="o">==</span> <span class="ss">:absent</span>

        <span class="vi">@demo</span> <span class="o">=</span> <span class="no">File</span><span class="nf">.read</span><span class="p">(</span><span class="n">demo_file</span><span class="p">)</span>
      <span class="k">end</span>

      <span class="c1"># @return a list of all lexers.</span>
      <span class="k">def </span><span class="nf">all</span>
        <span class="n">registry</span><span class="nf">.values.uniq</span>
      <span class="k">end</span>

      <span class="c1"># Guess which lexer to use based on a hash of info.</span>
      <span class="c1">#</span>
      <span class="c1"># @option info :mimetype</span>
      <span class="c1">#   A mimetype to guess by</span>
      <span class="c1"># @option info :filename</span>
      <span class="c1">#   A filename to guess by</span>
      <span class="c1"># @option info :source</span>
      <span class="c1">#   The source itself, which, if guessing by mimetype or filename</span>
      <span class="c1">#   fails, will be searched for shebangs, &lt;!DOCTYPE ...&gt; tags, and</span>
      <span class="c1">#   other hints.</span>
      <span class="c1">#</span>
      <span class="c1"># @see Lexer.analyze_text</span>
      <span class="k">def </span><span class="nf">guess</span><span class="p">(</span><span class="n">info</span><span class="o">=</span><span class="p">{})</span>
        <span class="n">by_mimetype</span> <span class="o">=</span> <span class="n">guess_by_mimetype</span><span class="p">(</span><span class="n">info</span><span class="o">[</span><span class="ss">:mimetype</span><span class="o">]</span><span class="p">)</span> <span class="k">if</span> <span class="n">info</span><span class="o">[</span><span class="ss">:mimetype</span><span class="o">]</span>
        <span class="k">return</span> <span class="n">by_mimetype</span> <span class="k">if</span> <span class="n">by_mimetype</span>

        <span class="n">by_filename</span> <span class="o">=</span> <span class="n">guess_by_filename</span><span class="p">(</span><span class="n">info</span><span class="o">[</span><span class="ss">:filename</span><span class="o">]</span><span class="p">)</span> <span class="k">if</span> <span class="n">info</span><span class="o">[</span><span class="ss">:filename</span><span class="o">]</span>
        <span class="k">return</span> <span class="n">by_filename</span> <span class="k">if</span> <span class="n">by_filename</span>

        <span class="n">by_source</span> <span class="o">=</span> <span class="n">guess_by_source</span><span class="p">(</span><span class="n">info</span><span class="o">[</span><span class="ss">:source</span><span class="o">]</span><span class="p">)</span> <span class="k">if</span> <span class="n">info</span><span class="o">[</span><span class="ss">:source</span><span class="o">]</span>
        <span class="k">return</span> <span class="n">by_source</span> <span class="k">if</span> <span class="n">by_source</span>

        <span class="c1"># guessing failed, just parse it as text</span>
        <span class="k">return</span> <span class="no">Lexers</span><span class="o">::</span><span class="no">Text</span>
      <span class="k">end</span>

      <span class="k">def </span><span class="nf">guess_by_mimetype</span><span class="p">(</span><span class="n">mt</span><span class="p">)</span>
        <span class="n">registry</span><span class="nf">.values.detect</span> <span class="k">do</span> <span class="o">|</span><span class="n">lexer</span><span class="o">|</span>
          <span class="n">lexer</span><span class="nf">.mimetypes.include?</span> <span class="n">mt</span>
        <span class="k">end</span>
      <span class="k">end</span>

      <span class="k">def </span><span class="nf">guess_by_filename</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="no">File</span><span class="nf">.basename</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="n">registry</span><span class="nf">.values.detect</span> <span class="k">do</span> <span class="o">|</span><span class="n">lexer</span><span class="o">|</span>
          <span class="n">lexer</span><span class="nf">.filenames.any?</span> <span class="k">do</span> <span class="o">|</span><span class="n">pattern</span><span class="o">|</span>
            <span class="no">File</span><span class="nf">.fnmatch?</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="no">File</span><span class="o">::</span><span class="no">FNM_DOTMATCH</span><span class="p">)</span>
          <span class="k">end</span>
        <span class="k">end</span>
      <span class="k">end</span>

      <span class="k">def </span><span class="nf">guess_by_source</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
        <span class="n">assert_utf8!</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>

        <span class="n">source</span> <span class="o">=</span> <span class="no">TextAnalyzer</span><span class="nf">.new</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>

        <span class="n">best_result</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">best_match</span> <span class="o">=</span> <span class="kp">nil</span>
        <span class="n">registry</span><span class="nf">.values.each</span> <span class="k">do</span> <span class="o">|</span><span class="n">lexer</span><span class="o">|</span>
          <span class="n">result</span> <span class="o">=</span> <span class="n">lexer</span><span class="nf">.analyze_text</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="o">||</span> <span class="mi">0</span>
          <span class="k">return</span> <span class="n">lexer</span> <span class="k">if</span> <span class="n">result</span> <span class="o">==</span> <span class="mi">1</span>

          <span class="k">if</span> <span class="n">result</span> <span class="o">&gt;</span> <span class="n">best_result</span>
            <span class="n">best_match</span> <span class="o">=</span> <span class="n">lexer</span>
            <span class="n">best_result</span> <span class="o">=</span> <span class="n">result</span>
          <span class="k">end</span>
        <span class="k">end</span>

        <span class="n">best_match</span>
      <span class="k">end</span>

      <span class="c1"># @private</span>
      <span class="k">def </span><span class="nf">register</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">lexer</span><span class="p">)</span>
        <span class="n">registry</span><span class="o">[</span><span class="nb">name</span><span class="nf">.to_s</span><span class="o">]</span> <span class="o">=</span> <span class="n">lexer</span>
      <span class="k">end</span>

      <span class="c1"># Used to specify or get the canonical name of this lexer class.</span>
      <span class="c1">#</span>
      <span class="c1"># @example</span>
      <span class="c1">#   class MyLexer &lt; Lexer</span>
      <span class="c1">#     tag &#39;foo&#39;</span>
      <span class="c1">#   end</span>
      <span class="c1">#</span>
      <span class="c1">#   MyLexer.tag # =&gt; &#39;foo&#39;</span>
      <span class="c1">#</span>
      <span class="c1">#   Lexer.find(&#39;foo&#39;) # =&gt; MyLexer</span>
      <span class="k">def </span><span class="nf">tag</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="kp">nil</span><span class="p">)</span>
        <span class="k">return</span> <span class="vi">@tag</span> <span class="k">if</span> <span class="n">t</span><span class="nf">.nil?</span>

        <span class="vi">@tag</span> <span class="o">=</span> <span class="n">t</span><span class="nf">.to_s</span>
        <span class="no">Lexer</span><span class="nf">.register</span><span class="p">(</span><span class="vi">@tag</span><span class="p">,</span> <span class="nb">self</span><span class="p">)</span>
      <span class="k">end</span>

      <span class="c1"># Used to specify alternate names this lexer class may be found by.</span>
      <span class="c1">#</span>
      <span class="c1"># @example</span>
      <span class="c1">#   class Erb &lt; Lexer</span>
      <span class="c1">#     tag &#39;erb&#39;</span>
      <span class="c1">#     aliases &#39;eruby&#39;, &#39;rhtml&#39;</span>
      <span class="c1">#   end</span>
      <span class="c1">#</span>
      <span class="c1">#   Lexer.find(&#39;eruby&#39;) # =&gt; Erb</span>
      <span class="k">def </span><span class="nf">aliases</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="n">args</span><span class="nf">.map!</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:to_s</span><span class="p">)</span>
        <span class="n">args</span><span class="nf">.each</span> <span class="p">{</span> <span class="o">|</span><span class="n">arg</span><span class="o">|</span> <span class="no">Lexer</span><span class="nf">.register</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">self</span><span class="p">)</span> <span class="p">}</span>
        <span class="p">(</span><span class="vi">@aliases</span> <span class="o">||=</span> <span class="o">[]</span><span class="p">)</span><span class="nf">.concat</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
      <span class="k">end</span>

      <span class="c1"># Specify a list of filename globs associated with this lexer.</span>
      <span class="c1">#</span>
      <span class="c1"># @example</span>
      <span class="c1">#   class Ruby &lt; Lexer</span>
      <span class="c1">#     filenames &#39;*.rb&#39;, &#39;*.ruby&#39;, &#39;Gemfile&#39;, &#39;Rakefile&#39;</span>
      <span class="c1">#   end</span>
      <span class="k">def </span><span class="nf">filenames</span><span class="p">(</span><span class="o">*</span><span class="n">fnames</span><span class="p">)</span>
        <span class="p">(</span><span class="vi">@filenames</span> <span class="o">||=</span> <span class="o">[]</span><span class="p">)</span><span class="nf">.concat</span><span class="p">(</span><span class="n">fnames</span><span class="p">)</span>
      <span class="k">end</span>

      <span class="c1"># Specify a list of mimetypes associated with this lexer.</span>
      <span class="c1">#</span>
      <span class="c1"># @example</span>
      <span class="c1">#   class Html &lt; Lexer</span>
      <span class="c1">#     mimetypes &#39;text/html&#39;, &#39;application/xhtml+xml&#39;</span>
      <span class="c1">#   end</span>
      <span class="k">def </span><span class="nf">mimetypes</span><span class="p">(</span><span class="o">*</span><span class="n">mts</span><span class="p">)</span>
        <span class="p">(</span><span class="vi">@mimetypes</span> <span class="o">||=</span> <span class="o">[]</span><span class="p">)</span><span class="nf">.concat</span><span class="p">(</span><span class="n">mts</span><span class="p">)</span>
      <span class="k">end</span>

      <span class="c1"># @private</span>
      <span class="k">def </span><span class="nf">assert_utf8!</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
        <span class="k">return</span> <span class="k">if</span> <span class="sx">%w(US-ASCII UTF-8)</span><span class="nf">.include?</span> <span class="n">str</span><span class="nf">.encoding.name</span>
        <span class="k">raise</span> <span class="no">EncodingError</span><span class="nf">.new</span><span class="p">(</span>
          <span class="s2">&quot;Bad encoding: </span><span class="si">#{</span><span class="n">str</span><span class="nf">.encoding.names.join</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">. &quot;</span> <span class="o">+</span>
          <span class="s2">&quot;Please convert your string to UTF-8.&quot;</span>
        <span class="p">)</span>
      <span class="k">end</span>

    <span class="kp">private</span>
      <span class="k">def </span><span class="nf">registry</span>
        <span class="vi">@registry</span> <span class="o">||=</span> <span class="p">{}</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="c1"># -*- instance methods -*- #</span>

    <span class="c1"># Create a new lexer with the given options.  Individual lexers may</span>
    <span class="c1"># specify extra options.  The only current globally accepted option</span>
    <span class="c1"># is `:debug`.</span>
    <span class="c1">#</span>
    <span class="c1"># @option opts :debug</span>
    <span class="c1">#   Prints debug information to stdout.  The particular info depends</span>
    <span class="c1">#   on the lexer in question.  In regex lexers, this will log the</span>
    <span class="c1">#   state stack at the beginning of each step, along with each regex</span>
    <span class="c1">#   tried and each stream consumed.  Try it, it&#39;s pretty useful.</span>
    <span class="k">def </span><span class="nf">initialize</span><span class="p">(</span><span class="n">opts</span><span class="o">=</span><span class="p">{})</span>
      <span class="n">options</span><span class="p">(</span><span class="n">opts</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="c1"># get and/or specify the options for this lexer.</span>
    <span class="k">def </span><span class="nf">options</span><span class="p">(</span><span class="n">o</span><span class="o">=</span><span class="p">{})</span>
      <span class="p">(</span><span class="vi">@options</span> <span class="o">||=</span> <span class="p">{})</span><span class="nf">.merge!</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

      <span class="nb">self</span><span class="nf">.class.default_options.merge</span><span class="p">(</span><span class="vi">@options</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="c1"># get or specify one option for this lexer</span>
    <span class="k">def </span><span class="nf">option</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="ss">:absent</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="ss">:absent</span>
        <span class="n">options</span><span class="o">[</span><span class="n">k</span><span class="o">]</span>
      <span class="k">else</span>
        <span class="n">options</span><span class="p">({</span> <span class="n">k</span> <span class="o">=&gt;</span> <span class="n">v</span> <span class="p">})</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="c1"># Leave a debug message if the `:debug` option is set.  The message</span>
    <span class="c1"># is given as a block because some debug messages contain calculated</span>
    <span class="c1"># information that is unnecessary for lexing in the real world.</span>
    <span class="c1">#</span>
    <span class="c1"># @example</span>
    <span class="c1">#   debug { &quot;hello, world!&quot; }</span>
    <span class="k">def </span><span class="nf">debug</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
      <span class="nb">puts</span><span class="p">(</span><span class="n">b</span><span class="nf">.call</span><span class="p">)</span> <span class="k">if</span> <span class="n">option</span> <span class="ss">:debug</span>
    <span class="k">end</span>

    <span class="c1"># @abstract</span>
    <span class="c1">#</span>
    <span class="c1"># Called after each lex is finished.  The default implementation</span>
    <span class="c1"># is a noop.</span>
    <span class="k">def </span><span class="nf">reset!</span>
    <span class="k">end</span>

    <span class="c1"># Given a string, yield [token, chunk] pairs.  If no block is given,</span>
    <span class="c1"># an enumerator is returned.</span>
    <span class="c1">#</span>
    <span class="c1"># @option opts :continue</span>
    <span class="c1">#   Continue the lex from the previous state (i.e. don&#39;t call #reset!)</span>
    <span class="k">def </span><span class="nf">lex</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">opts</span><span class="o">=</span><span class="p">{},</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">enum_for</span><span class="p">(</span><span class="ss">:lex</span><span class="p">,</span> <span class="n">string</span><span class="p">)</span> <span class="k">unless</span> <span class="nb">block_given?</span>

      <span class="no">Lexer</span><span class="nf">.assert_utf8!</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>

      <span class="n">reset!</span> <span class="k">unless</span> <span class="n">opts</span><span class="o">[</span><span class="ss">:continue</span><span class="o">]</span>

      <span class="c1"># consolidate consecutive tokens of the same type</span>
      <span class="n">last_token</span> <span class="o">=</span> <span class="kp">nil</span>
      <span class="n">last_val</span> <span class="o">=</span> <span class="kp">nil</span>
      <span class="n">stream_tokens</span><span class="p">(</span><span class="no">StringScanner</span><span class="nf">.new</span><span class="p">(</span><span class="n">string</span><span class="p">))</span> <span class="k">do</span> <span class="o">|</span><span class="n">tok</span><span class="p">,</span> <span class="n">val</span><span class="o">|</span>
        <span class="k">next</span> <span class="k">if</span> <span class="n">val</span><span class="nf">.empty?</span>

        <span class="k">if</span> <span class="n">tok</span> <span class="o">==</span> <span class="n">last_token</span>
          <span class="n">last_val</span> <span class="o">&lt;&lt;</span> <span class="n">val</span>
          <span class="k">next</span>
        <span class="k">end</span>

        <span class="n">b</span><span class="nf">.call</span><span class="p">(</span><span class="n">last_token</span><span class="p">,</span> <span class="n">last_val</span><span class="p">)</span> <span class="k">if</span> <span class="n">last_token</span>
        <span class="n">last_token</span> <span class="o">=</span> <span class="n">tok</span>
        <span class="n">last_val</span> <span class="o">=</span> <span class="n">val</span>
      <span class="k">end</span>

      <span class="n">b</span><span class="nf">.call</span><span class="p">(</span><span class="n">last_token</span><span class="p">,</span> <span class="n">last_val</span><span class="p">)</span> <span class="k">if</span> <span class="n">last_token</span>
    <span class="k">end</span>

    <span class="c1"># delegated to {Lexer.tag}</span>
    <span class="k">def </span><span class="nf">tag</span>
      <span class="nb">self</span><span class="nf">.class.tag</span>
    <span class="k">end</span>

    <span class="c1"># @abstract</span>
    <span class="c1">#</span>
    <span class="c1"># Yield `[token, chunk]` pairs, given a prepared input stream.  This</span>
    <span class="c1"># must be implemented.</span>
    <span class="c1">#</span>
    <span class="c1"># @param [StringScanner] stream</span>
    <span class="c1">#   the stream</span>
    <span class="k">def </span><span class="nf">stream_tokens</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
      <span class="k">raise</span> <span class="s1">&#39;abstract&#39;</span>
    <span class="k">end</span>

    <span class="c1"># @abstract</span>
    <span class="c1">#</span>
    <span class="c1"># Return a number between 0 and 1 indicating the likelihood that</span>
    <span class="c1"># the text given should be lexed with this lexer.  The default</span>
    <span class="c1"># implementation returns 0.</span>
    <span class="c1">#</span>
    <span class="c1"># @param [TextAnalyzer] text</span>
    <span class="c1">#   the text to be analyzed, with a couple of handy methods on it,</span>
    <span class="c1">#   like {TextAnalyzer#shebang?} and {TextAnalyzer#doctype?}</span>
    <span class="k">def </span><span class="nc">self</span><span class="o">.</span><span class="nf">analyze_text</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
      <span class="mi">0</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="k">module</span> <span class="nn">Rouge</span>
  <span class="k">module</span> <span class="nn">Lexers</span>
    <span class="k">class </span><span class="nc">C</span> <span class="o">&lt;</span> <span class="no">RegexLexer</span>
      <span class="n">tag</span> <span class="s1">&#39;c&#39;</span>
      <span class="n">filenames</span> <span class="s1">&#39;*.c&#39;</span><span class="p">,</span> <span class="s1">&#39;*.h&#39;</span><span class="p">,</span> <span class="s1">&#39;*.idc&#39;</span>
      <span class="n">mimetypes</span> <span class="s1">&#39;text/x-chdr&#39;</span><span class="p">,</span> <span class="s1">&#39;text/x-csrc&#39;</span>

      <span class="n">desc</span> <span class="s2">&quot;The C programming language&quot;</span>

      <span class="c1"># optional comment or whitespace</span>
      <span class="n">ws</span> <span class="o">=</span> <span class="sr">%r((?:</span><span class="se">\s</span><span class="sr">|//.*?</span><span class="se">\n</span><span class="sr">|/[*].*?[*]/)+)</span>
      <span class="nb">id</span> <span class="o">=</span> <span class="sr">/[a-zA-Z_][a-zA-Z0-9_]*/</span>

      <span class="n">keywords</span> <span class="o">=</span> <span class="sx">%w(
        auto break case const continue default do else enum extern
        for goto if register restricted return sizeof static struct
        switch typedef union volatile virtual while
      )</span>

      <span class="n">keywords_type</span> <span class="o">=</span> <span class="sx">%w(int long float short double char unsigned signed void)</span>

      <span class="n">__reserved</span> <span class="o">=</span> <span class="sx">%w(
        asm int8 based except int16 stdcall cdecl fastcall int32
        declspec finally int61 try leave
      )</span>

      <span class="n">state</span> <span class="ss">:whitespace</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">/^#if\s+0\b/</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span><span class="p">,</span> <span class="ss">:if_0</span>
        <span class="n">rule</span> <span class="sr">/^#/</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span><span class="p">,</span> <span class="ss">:macro</span>
        <span class="n">rule</span> <span class="sr">/^</span><span class="si">#{</span><span class="n">ws</span><span class="si">}</span><span class="sr">#if\s+0\b/</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span><span class="p">,</span> <span class="ss">:if_0</span>
        <span class="n">rule</span> <span class="sr">/^</span><span class="si">#{</span><span class="n">ws</span><span class="si">}</span><span class="sr">#/</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span><span class="p">,</span> <span class="ss">:macro</span>
        <span class="n">rule</span> <span class="sr">/^(\s*)(</span><span class="si">#{</span><span class="nb">id</span><span class="si">}</span><span class="sr">:(?!:))/</span> <span class="k">do</span>
          <span class="n">group</span> <span class="s1">&#39;Text&#39;</span>
          <span class="n">group</span> <span class="s1">&#39;Name.Label&#39;</span>
        <span class="k">end</span>

        <span class="n">rule</span> <span class="sr">/\s+/m</span><span class="p">,</span> <span class="s1">&#39;Text&#39;</span>
        <span class="n">rule</span> <span class="sr">/\\\n/</span><span class="p">,</span> <span class="s1">&#39;Text&#39;</span> <span class="c1"># line continuation</span>
        <span class="n">rule</span> <span class="sr">%r(//(</span><span class="se">\n</span><span class="sr">|(.|</span><span class="se">\n</span><span class="sr">)*?[^</span><span class="se">\\</span><span class="sr">]</span><span class="se">\n</span><span class="sr">))</span><span class="p">,</span> <span class="s1">&#39;Comment.Single&#39;</span>
        <span class="n">rule</span> <span class="sr">%r(/(</span><span class="se">\\\n</span><span class="sr">)?[*](.|</span><span class="se">\n</span><span class="sr">)*?[*](</span><span class="se">\\\n</span><span class="sr">)?/)</span><span class="p">,</span> <span class="s1">&#39;Comment.Multiline&#39;</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:statements</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">/L?&quot;/</span><span class="p">,</span> <span class="s1">&#39;Literal.String&#39;</span><span class="p">,</span> <span class="ss">:string</span>
        <span class="n">rule</span> <span class="sr">%r(L?&#39;(</span><span class="se">\\</span><span class="sr">.|</span><span class="se">\\</span><span class="sr">[0-7]{1,3}|</span><span class="se">\\</span><span class="sr">x[a-f0-9]{1,2}|[^</span><span class="se">\\</span><span class="sr">&#39;</span><span class="se">\n</span><span class="sr">])&#39;)i</span><span class="p">,</span> <span class="s1">&#39;Literal.String.Char&#39;</span>
        <span class="n">rule</span> <span class="sr">%r((</span><span class="se">\d</span><span class="sr">+</span><span class="se">\.\d</span><span class="sr">*|</span><span class="se">\.\d</span><span class="sr">+|</span><span class="se">\d</span><span class="sr">+)[e][+-]?</span><span class="se">\d</span><span class="sr">+[lu]*)i</span><span class="p">,</span> <span class="s1">&#39;Literal.Number.Float&#39;</span>
        <span class="n">rule</span> <span class="sr">/0x[0-9a-f]+[lu]*/i</span><span class="p">,</span> <span class="s1">&#39;Literal.Number.Hex&#39;</span>
        <span class="n">rule</span> <span class="sr">/0[0-7]+[lu]*/i</span><span class="p">,</span> <span class="s1">&#39;Literal.Number.Oct&#39;</span>
        <span class="n">rule</span> <span class="sr">/\d+[lu]*/i</span><span class="p">,</span> <span class="s1">&#39;Literal.Number.Integer&#39;</span>
        <span class="n">rule</span> <span class="sr">%r(</span><span class="se">\*</span><span class="sr">/)</span><span class="p">,</span> <span class="s1">&#39;Error&#39;</span>
        <span class="n">rule</span> <span class="sr">%r([~!%^&amp;*+=</span><span class="se">\|</span><span class="sr">?:&lt;&gt;/-])</span><span class="p">,</span> <span class="s1">&#39;Operator&#39;</span>
        <span class="n">rule</span> <span class="sr">/[()\[\],.]/</span><span class="p">,</span> <span class="s1">&#39;Punctuation&#39;</span>
        <span class="n">rule</span> <span class="sr">/\bcase\b/</span><span class="p">,</span> <span class="s1">&#39;Keyword&#39;</span><span class="p">,</span> <span class="ss">:case</span>
        <span class="n">rule</span> <span class="sr">/(?:</span><span class="si">#{</span><span class="n">keywords</span><span class="nf">.join</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">)</span><span class="si">}</span><span class="sr">)\b/</span><span class="p">,</span> <span class="s1">&#39;Keyword&#39;</span>
        <span class="n">rule</span> <span class="sr">/(?:</span><span class="si">#{</span><span class="n">keywords_type</span><span class="nf">.join</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">)</span><span class="si">}</span><span class="sr">)\b/</span><span class="p">,</span> <span class="s1">&#39;Keyword.Type&#39;</span>
        <span class="n">rule</span> <span class="sr">/(?:_{0,2}inline|naked|restrict|thread|typename)\b/</span><span class="p">,</span> <span class="s1">&#39;Keyword.Reserved&#39;</span>
        <span class="n">rule</span> <span class="sr">/__(?:</span><span class="si">#{</span><span class="n">__reserved</span><span class="nf">.join</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">)</span><span class="si">}</span><span class="sr">)\b/</span><span class="p">,</span> <span class="s1">&#39;Keyword.Reserved&#39;</span>
        <span class="n">rule</span> <span class="sr">/(?:true|false|NULL)\b/</span><span class="p">,</span> <span class="s1">&#39;Name.Builtin&#39;</span>
        <span class="n">rule</span> <span class="nb">id</span><span class="p">,</span> <span class="s1">&#39;Name&#39;</span>
        <span class="n">rule</span> <span class="sr">/\s+/m</span><span class="p">,</span> <span class="s1">&#39;Text&#39;</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:case</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">/:/</span><span class="p">,</span> <span class="s1">&#39;Punctuation&#39;</span><span class="p">,</span> <span class="ss">:pop!</span>
        <span class="n">mixin</span> <span class="ss">:statements</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:root</span> <span class="k">do</span>
        <span class="n">mixin</span> <span class="ss">:whitespace</span>

        <span class="c1"># functions</span>
        <span class="n">rule</span> <span class="sr">%r(
          ([</span><span class="se">\w</span><span class="sr">*</span><span class="se">\s</span><span class="sr">]+?[</span><span class="se">\s</span><span class="sr">*]) # return arguments
          (</span><span class="si">#{</span><span class="nb">id</span><span class="si">}</span><span class="sr">)          # function name
          (</span><span class="se">\s</span><span class="sr">*</span><span class="se">\(</span><span class="sr">[^;]*?</span><span class="se">\)</span><span class="sr">)  # signature
          (</span><span class="si">#{</span><span class="n">ws</span><span class="si">}</span><span class="sr">)({)         # open brace
        )mx</span> <span class="k">do</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span>
          <span class="c1"># TODO: do this better.</span>
          <span class="n">delegate</span> <span class="n">C</span><span class="p">,</span> <span class="n">m</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>
          <span class="n">token</span> <span class="s1">&#39;Name.Function&#39;</span><span class="p">,</span> <span class="n">m</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span>
          <span class="n">delegate</span> <span class="n">C</span><span class="p">,</span> <span class="n">m</span><span class="o">[</span><span class="mi">3</span><span class="o">]</span>
          <span class="n">delegate</span> <span class="n">C</span><span class="p">,</span> <span class="n">m</span><span class="o">[</span><span class="mi">4</span><span class="o">]</span>
          <span class="n">token</span> <span class="s1">&#39;Punctuation&#39;</span><span class="p">,</span> <span class="n">m</span><span class="o">[</span><span class="mi">5</span><span class="o">]</span>
          <span class="n">push</span> <span class="ss">:function</span>
        <span class="k">end</span>

        <span class="c1"># function declarations</span>
        <span class="n">rule</span> <span class="sr">%r(
          ([</span><span class="se">\w</span><span class="sr">*</span><span class="se">\s</span><span class="sr">]+?[</span><span class="se">\s</span><span class="sr">*]) # return arguments
          (</span><span class="si">#{</span><span class="nb">id</span><span class="si">}</span><span class="sr">)          # function name
          (</span><span class="se">\s</span><span class="sr">*</span><span class="se">\(</span><span class="sr">[^;]*?</span><span class="se">\)</span><span class="sr">)  # signature
          (</span><span class="si">#{</span><span class="n">ws</span><span class="si">}</span><span class="sr">)(;)       # semicolon
        )mx</span> <span class="k">do</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span>
          <span class="c1"># TODO: do this better.</span>
          <span class="n">delegate</span> <span class="n">C</span><span class="p">,</span> <span class="n">m</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>
          <span class="n">token</span> <span class="s1">&#39;Name.Function&#39;</span>
          <span class="n">delegate</span> <span class="n">C</span><span class="p">,</span> <span class="n">m</span><span class="o">[</span><span class="mi">3</span><span class="o">]</span>
          <span class="n">delegate</span> <span class="n">C</span><span class="p">,</span> <span class="n">m</span><span class="o">[</span><span class="mi">4</span><span class="o">]</span>
          <span class="n">token</span> <span class="s1">&#39;Punctuation&#39;</span>
          <span class="n">push</span> <span class="ss">:statement</span>
        <span class="k">end</span>

        <span class="n">rule</span><span class="p">(</span><span class="sr">//</span><span class="p">)</span> <span class="p">{</span> <span class="n">push</span> <span class="ss">:statement</span> <span class="p">}</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:statement</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">/;/</span><span class="p">,</span> <span class="s1">&#39;Punctuation&#39;</span><span class="p">,</span> <span class="ss">:pop!</span>
        <span class="n">mixin</span> <span class="ss">:whitespace</span>
        <span class="n">mixin</span> <span class="ss">:statements</span>
        <span class="n">rule</span> <span class="sr">/[{}]/</span><span class="p">,</span> <span class="s1">&#39;Punctuation&#39;</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:function</span> <span class="k">do</span>
        <span class="n">mixin</span> <span class="ss">:whitespace</span>
        <span class="n">mixin</span> <span class="ss">:statements</span>
        <span class="n">rule</span> <span class="sr">/;/</span><span class="p">,</span> <span class="s1">&#39;Punctuation&#39;</span>
        <span class="n">rule</span> <span class="sr">/{/</span><span class="p">,</span> <span class="s1">&#39;Punctuation&#39;</span><span class="p">,</span> <span class="ss">:function</span>
        <span class="n">rule</span> <span class="sr">/}/</span><span class="p">,</span> <span class="s1">&#39;Punctuation&#39;</span><span class="p">,</span> <span class="ss">:pop!</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:string</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">/&quot;/</span><span class="p">,</span> <span class="s1">&#39;Literal.String&#39;</span><span class="p">,</span> <span class="ss">:pop!</span>
        <span class="n">rule</span> <span class="sr">/\\([\\abfnrtv&quot;&#39;]|x[a-fA-F0-9]{2,4}|[0-7]{1,3})/</span><span class="p">,</span> <span class="s1">&#39;Literal.String.Escape&#39;</span>
        <span class="n">rule</span> <span class="sr">/[^\\&quot;\n]+/</span><span class="p">,</span> <span class="s1">&#39;Literal.String&#39;</span>
        <span class="n">rule</span> <span class="sr">/\\\n/</span><span class="p">,</span> <span class="s1">&#39;Literal.String&#39;</span>
        <span class="n">rule</span> <span class="sr">/\\/</span><span class="p">,</span> <span class="s1">&#39;Literal.String&#39;</span> <span class="c1"># stray backslash</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:macro</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">%r([^/</span><span class="se">\n</span><span class="sr">]+)</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span>
        <span class="n">rule</span> <span class="sr">%r(/[*].*?[*]/)m</span><span class="p">,</span> <span class="s1">&#39;Comment.Multiliine&#39;</span>
        <span class="n">rule</span> <span class="sr">%r(//.*$)</span><span class="p">,</span> <span class="s1">&#39;Comment.Single&#39;</span>
        <span class="n">rule</span> <span class="sr">%r(/)</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span>
        <span class="n">rule</span> <span class="sr">/(?&lt;=\\)\n/</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span>
        <span class="n">rule</span> <span class="sr">/\n/</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span><span class="p">,</span> <span class="ss">:pop!</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:if_0</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">/^\s*#if.*?(?&lt;!\\)\n/</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span><span class="p">,</span> <span class="ss">:if_0</span>
        <span class="n">rule</span> <span class="sr">/^\s*#el(?:se|if).*\n/</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span><span class="p">,</span> <span class="ss">:pop!</span>
        <span class="n">rule</span> <span class="sr">/^\s*#endif.*?(?&lt;!\\)\n/</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span><span class="p">,</span> <span class="ss">:pop!</span>
        <span class="n">rule</span> <span class="sr">/.*?\n/</span><span class="p">,</span> <span class="s1">&#39;Comment&#39;</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="k">module</span> <span class="nn">Rouge</span>
  <span class="k">module</span> <span class="nn">Lexers</span>
    <span class="k">class </span><span class="nc">Clojure</span> <span class="o">&lt;</span> <span class="no">RegexLexer</span>
      <span class="n">desc</span> <span class="s2">&quot;The Clojure programming language (clojure.org)&quot;</span>

      <span class="n">tag</span> <span class="s1">&#39;clojure&#39;</span>
      <span class="n">aliases</span> <span class="s1">&#39;clj&#39;</span>

      <span class="n">filenames</span> <span class="s1">&#39;*.clj&#39;</span>

      <span class="n">mimetypes</span> <span class="s1">&#39;text/x-clojure&#39;</span><span class="p">,</span> <span class="s1">&#39;application/x-clojure&#39;</span>

      <span class="k">def </span><span class="nc">self</span><span class="o">.</span><span class="nf">keywords</span>
        <span class="vi">@keywords</span> <span class="o">||=</span> <span class="no">Set</span><span class="nf">.new</span> <span class="sx">%w(
          fn def defn defmacro defmethod defmulti defn- defstruct if
          cond let for
        )</span>
      <span class="k">end</span>

      <span class="k">def </span><span class="nc">self</span><span class="o">.</span><span class="nf">builtins</span>
        <span class="vi">@builtins</span> <span class="o">||=</span> <span class="no">Set</span><span class="nf">.new</span> <span class="sx">%w(
          . ..  * + - -&gt; / &lt; &lt;= = == &gt; &gt;= accessor agent agent-errors
          aget alength all-ns alter and append-child apply array-map
          aset aset-boolean aset-byte aset-char aset-double aset-float
          aset-int aset-long aset-short assert assoc await await-for bean
          binding bit-and bit-not bit-or bit-shift-left bit-shift-right
          bit-xor boolean branch?  butlast byte cast char children
          class clear-agent-errors comment commute comp comparator
          complement concat conj cons constantly construct-proxy
          contains? count create-ns create-struct cycle dec  deref
          difference disj dissoc distinct doall doc dorun doseq dosync
          dotimes doto double down drop drop-while edit end? ensure eval
          every? false? ffirst file-seq filter find find-doc find-ns
          find-var first float flush fnseq frest gensym get-proxy-class
          get hash-map hash-set identical? identity if-let import in-ns
          inc index insert-child insert-left insert-right inspect-table
          inspect-tree instance? int interleave intersection into
          into-array iterate join key keys keyword keyword? last lazy-cat
          lazy-cons left lefts line-seq list* list load load-file locking
          long loop macroexpand macroexpand-1 make-array make-node map
          map-invert map? mapcat max max-key memfn merge merge-with meta
          min min-key name namespace neg? new newline next nil? node not
          not-any? not-every? not= ns-imports ns-interns ns-map ns-name
          ns-publics ns-refers ns-resolve ns-unmap nth nthrest or parse
          partial path peek pop pos? pr pr-str print print-str println
          println-str prn prn-str project proxy proxy-mappings quot
          rand rand-int range re-find re-groups re-matcher re-matches
          re-pattern re-seq read read-line reduce ref ref-set refer rem
          remove remove-method remove-ns rename rename-keys repeat replace
          replicate resolve rest resultset-seq reverse rfirst right
          rights root rrest rseq second select select-keys send send-off
          seq seq-zip seq? set short slurp some sort sort-by sorted-map
          sorted-map-by sorted-set special-symbol? split-at split-with
          str string?  struct struct-map subs subvec symbol symbol?
          sync take take-nth take-while test time to-array to-array-2d
          tree-seq true? union up update-proxy val vals var-get var-set
          var? vector vector-zip vector? when when-first when-let
          when-not with-local-vars with-meta with-open with-out-str
          xml-seq xml-zip zero? zipmap zipper&#39;
        )</span>
      <span class="k">end</span>

      <span class="n">identifier</span> <span class="o">=</span> <span class="sr">%r([</span><span class="se">\w</span><span class="sr">!$%*+,&lt;=&gt;?/.-]+)</span>

      <span class="k">def </span><span class="nf">name_token</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;Keyword&#39;</span> <span class="k">if</span> <span class="nb">self</span><span class="nf">.class.keywords.include?</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;Name.Builtin&#39;</span> <span class="k">if</span> <span class="nb">self</span><span class="nf">.class.builtins.include?</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
        <span class="kp">nil</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:root</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">/;.*?\n/</span><span class="p">,</span> <span class="s1">&#39;Comment.Single&#39;</span>
        <span class="n">rule</span> <span class="sr">/\s+/m</span><span class="p">,</span> <span class="s1">&#39;Text.Whitespace&#39;</span>

        <span class="n">rule</span> <span class="sr">/-?\d+\.\d+/</span><span class="p">,</span> <span class="s1">&#39;Literal.Number.Float&#39;</span>
        <span class="n">rule</span> <span class="sr">/-?\d+/</span><span class="p">,</span> <span class="s1">&#39;Literal.Number.Integer&#39;</span>
        <span class="n">rule</span> <span class="sr">/0x-?[0-9a-fA-F]+/</span><span class="p">,</span> <span class="s1">&#39;Literal.Number.Hex&#39;</span>

        <span class="n">rule</span> <span class="sr">/&quot;(\\.|[^&quot;])*&quot;/</span><span class="p">,</span> <span class="s1">&#39;Literal.String&#39;</span>
        <span class="n">rule</span> <span class="sr">/&#39;</span><span class="si">#{</span><span class="n">identifier</span><span class="si">}</span><span class="sr">/</span><span class="p">,</span> <span class="s1">&#39;Literal.String.Symbol&#39;</span>
        <span class="n">rule</span> <span class="sr">/\\(.|[a-z]+)/i</span><span class="p">,</span> <span class="s1">&#39;Literal.String.Char&#39;</span>

        <span class="n">rule</span> <span class="sr">/:</span><span class="si">#{</span><span class="n">identifier</span><span class="si">}</span><span class="sr">/</span><span class="p">,</span> <span class="s1">&#39;Name.Constant&#39;</span>

        <span class="n">rule</span> <span class="sr">/~@|[`\&#39;#^~&amp;]/</span><span class="p">,</span> <span class="s1">&#39;Operator&#39;</span>

        <span class="n">rule</span> <span class="sr">/(\()(\s*)(</span><span class="si">#{</span><span class="n">identifier</span><span class="si">}</span><span class="sr">)/m</span> <span class="k">do</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span>
          <span class="n">token</span> <span class="s1">&#39;Punctuation&#39;</span><span class="p">,</span> <span class="n">m</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>
          <span class="n">token</span> <span class="s1">&#39;Text.Whitespace&#39;</span><span class="p">,</span> <span class="n">m</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span>
          <span class="n">token</span><span class="p">(</span><span class="n">name_token</span><span class="p">(</span><span class="n">m</span><span class="o">[</span><span class="mi">3</span><span class="o">]</span><span class="p">)</span> <span class="o">||</span> <span class="s1">&#39;Name.Function&#39;</span><span class="p">,</span> <span class="n">m</span><span class="o">[</span><span class="mi">3</span><span class="o">]</span><span class="p">)</span>
        <span class="k">end</span>

        <span class="n">rule</span> <span class="n">identifier</span> <span class="k">do</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span>
          <span class="n">token</span> <span class="n">name_token</span><span class="p">(</span><span class="n">m</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">)</span> <span class="o">||</span> <span class="s1">&#39;Name.Variable&#39;</span>
        <span class="k">end</span>

        <span class="c1"># vectors</span>
        <span class="n">rule</span> <span class="sr">/[\[\]]/</span><span class="p">,</span> <span class="s1">&#39;Punctuation&#39;</span>

        <span class="c1"># maps</span>
        <span class="n">rule</span> <span class="sr">/[{}]/</span><span class="p">,</span> <span class="s1">&#39;Punctuation&#39;</span>

        <span class="c1"># parentheses</span>
        <span class="n">rule</span> <span class="sr">/[()]/</span><span class="p">,</span> <span class="s1">&#39;Punctuation&#39;</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="k">module</span> <span class="nn">Rouge</span>
  <span class="k">module</span> <span class="nn">Lexers</span>
    <span class="k">class </span><span class="nc">Coffeescript</span> <span class="o">&lt;</span> <span class="no">RegexLexer</span>
      <span class="n">tag</span> <span class="s1">&#39;coffeescript&#39;</span>
      <span class="n">aliases</span> <span class="s1">&#39;coffee&#39;</span><span class="p">,</span> <span class="s1">&#39;coffee-script&#39;</span>
      <span class="n">filenames</span> <span class="s1">&#39;*.coffee&#39;</span><span class="p">,</span> <span class="s1">&#39;Cakefile&#39;</span>
      <span class="n">mimetypes</span> <span class="s1">&#39;text/coffeescript&#39;</span>

      <span class="n">desc</span> <span class="s1">&#39;The Coffeescript programming language (coffeescript.org)&#39;</span>

      <span class="k">def </span><span class="nc">self</span><span class="o">.</span><span class="nf">analyze_text</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">text</span><span class="nf">.shebang?</span> <span class="s1">&#39;coffee&#39;</span>
      <span class="k">end</span>

      <span class="k">def </span><span class="nc">self</span><span class="o">.</span><span class="nf">keywords</span>
        <span class="vi">@keywords</span> <span class="o">||=</span> <span class="no">Set</span><span class="nf">.new</span> <span class="sx">%w(
          for in of while break return continue switch when then if else
          throw try catch finally new delete typeof instanceof super
          extends this class by
        )</span>
      <span class="k">end</span>

      <span class="k">def </span><span class="nc">self</span><span class="o">.</span><span class="nf">constants</span>
        <span class="vi">@constants</span> <span class="o">||=</span> <span class="no">Set</span><span class="nf">.new</span> <span class="sx">%w(
          true false yes no on off null NaN Infinity undefined
        )</span>
      <span class="k">end</span>

      <span class="k">def </span><span class="nc">self</span><span class="o">.</span><span class="nf">builtins</span>
        <span class="vi">@builtins</span> <span class="o">||=</span> <span class="no">Set</span><span class="nf">.new</span> <span class="sx">%w(
          Array Boolean Date Error Function Math netscape Number Object
          Packages RegExp String sun decodeURI decodeURIComponent
          encodeURI encodeURIComponent eval isFinite isNaN parseFloat
          parseInt document window
        )</span>
      <span class="k">end</span>

      <span class="nb">id</span> <span class="o">=</span> <span class="sr">/[$a-zA-Z_][a-zA-Z0-9_]*/</span>
      <span class="n">lval</span> <span class="o">=</span> <span class="sr">/@?</span><span class="si">#{</span><span class="nb">id</span><span class="si">}</span><span class="sr">([.]</span><span class="si">#{</span><span class="nb">id</span><span class="si">}</span><span class="sr">)*/</span>

      <span class="n">state</span> <span class="ss">:comments_and_whitespace</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">/\s+/m</span><span class="p">,</span> <span class="s1">&#39;Text&#39;</span>
        <span class="n">rule</span> <span class="sr">/###.*?###/m</span><span class="p">,</span> <span class="s1">&#39;Comment.Multiline&#39;</span>
        <span class="n">rule</span> <span class="sr">/#.*?\n/</span><span class="p">,</span> <span class="s1">&#39;Comment.Single&#39;</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:multiline_regex</span> <span class="k">do</span>
        <span class="n">mixin</span> <span class="ss">:comments_and_whitespace</span>
        <span class="n">rule</span> <span class="sr">%r(///([gim]+</span><span class="se">\b</span><span class="sr">|</span><span class="se">\B</span><span class="sr">))</span><span class="p">,</span> <span class="s1">&#39;Literal.String.Regex&#39;</span><span class="p">,</span> <span class="ss">:pop!</span>
        <span class="n">rule</span> <span class="sr">%r(/)</span><span class="p">,</span> <span class="s1">&#39;Literal.String.Regex&#39;</span>
        <span class="n">rule</span> <span class="sr">%r([^/#]+)</span><span class="p">,</span> <span class="s1">&#39;Literal.String.Regex&#39;</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:slash_starts_regex</span> <span class="k">do</span>
        <span class="n">mixin</span> <span class="ss">:comments_and_whitespace</span>
        <span class="n">rule</span> <span class="sr">%r(///)</span> <span class="k">do</span>
          <span class="n">token</span> <span class="s1">&#39;Literal.String.Regex&#39;</span>
          <span class="n">pop!</span><span class="p">;</span> <span class="n">push</span> <span class="ss">:multiline_regex</span>
        <span class="k">end</span>

        <span class="n">rule</span> <span class="sr">%r(
          /(</span><span class="se">\\</span><span class="sr">.|[^</span><span class="se">\[</span><span class="sr">/</span><span class="se">\\\n</span><span class="sr">]|</span><span class="se">\[</span><span class="sr">(</span><span class="se">\\</span><span class="sr">.|[^</span><span class="se">\]\\\n</span><span class="sr">])*</span><span class="se">\]</span><span class="sr">)+/ # a regex
          ([gim]+</span><span class="se">\b</span><span class="sr">|</span><span class="se">\B</span><span class="sr">)
        )x</span><span class="p">,</span> <span class="s1">&#39;Literal.String.Regex&#39;</span><span class="p">,</span> <span class="ss">:pop!</span>

        <span class="n">rule</span><span class="p">(</span><span class="sr">//</span><span class="p">)</span> <span class="p">{</span> <span class="n">pop!</span> <span class="p">}</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:root</span> <span class="k">do</span>
        <span class="n">rule</span><span class="p">(</span><span class="sr">%r(^(?=</span><span class="se">\s</span><span class="sr">|/|&lt;!--))</span><span class="p">)</span> <span class="p">{</span> <span class="n">push</span> <span class="ss">:slash_starts_regex</span> <span class="p">}</span>
        <span class="n">mixin</span> <span class="ss">:comments_and_whitespace</span>
        <span class="n">rule</span> <span class="sr">%r(
          [+][+]|--|~|&amp;&amp;|</span><span class="se">\b</span><span class="sr">and</span><span class="se">\b</span><span class="sr">|</span><span class="se">\b</span><span class="sr">or</span><span class="se">\b</span><span class="sr">|</span><span class="se">\b</span><span class="sr">is</span><span class="se">\b</span><span class="sr">|</span><span class="se">\b</span><span class="sr">isnt</span><span class="se">\b</span><span class="sr">|</span><span class="se">\b</span><span class="sr">not</span><span class="se">\b</span><span class="sr">|[?]|:|=|
          [|][|]|</span><span class="se">\\</span><span class="sr">(?=</span><span class="se">\n</span><span class="sr">)|(&lt;&lt;|&gt;&gt;&gt;?|==?|!=?|[-&lt;&gt;+*`%&amp;|^/])=?
        )x</span><span class="p">,</span> <span class="s1">&#39;Operator&#39;</span><span class="p">,</span> <span class="ss">:slash_starts_regex</span>

        <span class="n">rule</span> <span class="sr">/[-=]&gt;/</span><span class="p">,</span> <span class="s1">&#39;Name.Function&#39;</span>

        <span class="n">rule</span> <span class="sr">/(@)([ \t]*)(</span><span class="si">#{</span><span class="nb">id</span><span class="si">}</span><span class="sr">)/</span> <span class="k">do</span>
          <span class="n">group</span> <span class="s1">&#39;Name.Variable.Instance&#39;</span><span class="p">;</span> <span class="n">group</span> <span class="s1">&#39;Text&#39;</span>
          <span class="n">group</span> <span class="s1">&#39;Name.Attribute&#39;</span>
          <span class="n">push</span> <span class="ss">:slash_starts_regex</span>
        <span class="k">end</span>

        <span class="n">rule</span> <span class="sr">/([.])([ \t]*)(</span><span class="si">#{</span><span class="nb">id</span><span class="si">}</span><span class="sr">)/</span> <span class="k">do</span>
          <span class="n">group</span> <span class="s1">&#39;Punctuation&#39;</span><span class="p">;</span> <span class="n">group</span> <span class="s1">&#39;Text&#39;</span>
          <span class="n">group</span> <span class="s1">&#39;Name.Attribute&#39;</span>
          <span class="n">push</span> <span class="ss">:slash_starts_regex</span>
        <span class="k">end</span>

        <span class="n">rule</span> <span class="sr">/</span><span class="si">#{</span><span class="nb">id</span><span class="si">}</span><span class="sr">(?=\s*:)/</span><span class="p">,</span> <span class="s1">&#39;Name.Attribute&#39;</span><span class="p">,</span> <span class="ss">:slash_starts_regex</span>

        <span class="n">rule</span> <span class="sr">/</span><span class="si">#{</span><span class="nb">id</span><span class="si">}</span><span class="sr">/</span><span class="p">,</span> <span class="s1">&#39;Name.Other&#39;</span><span class="p">,</span> <span class="ss">:slash_starts_regex</span>

        <span class="n">rule</span> <span class="sr">/[{(\[;,]/</span><span class="p">,</span> <span class="s1">&#39;Punctuation&#39;</span><span class="p">,</span> <span class="ss">:slash_starts_regex</span>
        <span class="n">rule</span> <span class="sr">/[})\].]/</span><span class="p">,</span> <span class="s1">&#39;Punctuation&#39;</span>

        <span class="n">rule</span> <span class="sr">/\d+[.]\d+([eE]\d+)?[fd]?/</span><span class="p">,</span> <span class="s1">&#39;Literal.Number.Float&#39;</span>
        <span class="n">rule</span> <span class="sr">/0x[0-9a-fA-F]+/</span><span class="p">,</span> <span class="s1">&#39;Literal.Number.Hex&#39;</span>
        <span class="n">rule</span> <span class="sr">/\d+/</span><span class="p">,</span> <span class="s1">&#39;Literal.Number.Integer&#39;</span>
        <span class="n">rule</span> <span class="sr">/&quot;&quot;&quot;/</span><span class="p">,</span> <span class="s1">&#39;Literal.String&#39;</span><span class="p">,</span> <span class="ss">:tdqs</span>
        <span class="n">rule</span> <span class="sr">/&#39;&#39;&#39;/</span><span class="p">,</span> <span class="s1">&#39;Literal.String&#39;</span><span class="p">,</span> <span class="ss">:tsqs</span>
        <span class="n">rule</span> <span class="sr">/&quot;/</span><span class="p">,</span> <span class="s1">&#39;Literal.String&#39;</span><span class="p">,</span> <span class="ss">:dqs</span>
        <span class="n">rule</span> <span class="sr">/&#39;/</span><span class="p">,</span> <span class="s1">&#39;Literal.String&#39;</span><span class="p">,</span> <span class="ss">:sqs</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:strings</span> <span class="k">do</span>
        <span class="c1"># all coffeescript strings are multi-line</span>
        <span class="n">rule</span> <span class="sr">/[^#\\&#39;&quot;]+/m</span><span class="p">,</span> <span class="s1">&#39;Literal.String&#39;</span>

        <span class="n">rule</span> <span class="sr">/\\./</span><span class="p">,</span> <span class="s1">&#39;Literal.String.Escape&#39;</span>
        <span class="n">rule</span> <span class="sr">/#/</span><span class="p">,</span> <span class="s1">&#39;Literal.String&#39;</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:double_strings</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">/&#39;/</span><span class="p">,</span> <span class="s1">&#39;Literal.String&#39;</span>
        <span class="n">mixin</span> <span class="ss">:has_interpolation</span>
        <span class="n">mixin</span> <span class="ss">:strings</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:single_strings</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">/&quot;/</span><span class="p">,</span> <span class="s1">&#39;Literal.String&#39;</span>
        <span class="n">mixin</span> <span class="ss">:strings</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:interpolation</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">/}/</span><span class="p">,</span> <span class="s1">&#39;Literal.String.Interpol&#39;</span><span class="p">,</span> <span class="ss">:pop!</span>
        <span class="n">mixin</span> <span class="ss">:root</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:has_interpolation</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">/[#][{]/</span><span class="p">,</span> <span class="s1">&#39;Literal.String.Interpol&#39;</span><span class="p">,</span> <span class="ss">:interpolation</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:dqs</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">/&quot;/</span><span class="p">,</span> <span class="s1">&#39;Literal.String&#39;</span><span class="p">,</span> <span class="ss">:pop!</span>
        <span class="n">mixin</span> <span class="ss">:double_strings</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:tdqs</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">/&quot;&quot;&quot;/</span><span class="p">,</span> <span class="s1">&#39;Literal.String&#39;</span><span class="p">,</span> <span class="ss">:pop!</span>
        <span class="n">rule</span> <span class="sr">/&quot;/</span><span class="p">,</span> <span class="s1">&#39;Literal.String&#39;</span>
        <span class="n">mixin</span> <span class="ss">:double_strings</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:sqs</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">/&#39;/</span><span class="p">,</span> <span class="s1">&#39;Literal.String&#39;</span><span class="p">,</span> <span class="ss">:pop!</span>
        <span class="n">mixin</span> <span class="ss">:single_strings</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:tsqs</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">/&#39;&#39;&#39;/</span><span class="p">,</span> <span class="s1">&#39;Literal.String&#39;</span><span class="p">,</span> <span class="ss">:pop!</span>
        <span class="n">rule</span> <span class="sr">/&#39;/</span><span class="p">,</span> <span class="s1">&#39;Literal.String&#39;</span>
        <span class="n">mixin</span> <span class="ss">:single_strings</span>
      <span class="k">end</span>

      <span class="n">postprocess</span> <span class="s1">&#39;Name&#39;</span> <span class="k">do</span> <span class="o">|</span><span class="n">tok</span><span class="p">,</span> <span class="n">val</span><span class="o">|</span>
        <span class="k">if</span> <span class="n">tok</span><span class="nf">.name</span> <span class="o">==</span> <span class="s1">&#39;Name.Attribute&#39;</span>
          <span class="c1"># pass. leave attributes alone.</span>
        <span class="k">elsif</span> <span class="nb">self</span><span class="nf">.class.keywords.include?</span> <span class="n">val</span>
          <span class="n">tok</span> <span class="o">=</span> <span class="s1">&#39;Keyword&#39;</span>
        <span class="k">elsif</span> <span class="nb">self</span><span class="nf">.class.constants.include?</span> <span class="n">val</span>
          <span class="n">tok</span> <span class="o">=</span> <span class="s1">&#39;Name.Constant&#39;</span>
        <span class="k">elsif</span> <span class="nb">self</span><span class="nf">.class.builtins.include?</span> <span class="n">val</span>
          <span class="n">tok</span> <span class="o">=</span> <span class="s1">&#39;Name.Builtin&#39;</span>
        <span class="k">end</span>

        <span class="n">token</span> <span class="n">tok</span><span class="p">,</span> <span class="n">val</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="c1"># stdlib</span>
<span class="nb">require</span> <span class="s1">&#39;set&#39;</span>

<span class="k">module</span> <span class="nn">Rouge</span>
  <span class="k">module</span> <span class="nn">Lexers</span>
    <span class="k">class </span><span class="nc">CommonLisp</span> <span class="o">&lt;</span> <span class="no">RegexLexer</span>
      <span class="n">desc</span> <span class="s2">&quot;The Common Lisp variant of Lisp (common-lisp.net)&quot;</span>
      <span class="n">tag</span> <span class="s1">&#39;common_lisp&#39;</span>
      <span class="n">aliases</span> <span class="s1">&#39;cl&#39;</span><span class="p">,</span> <span class="s1">&#39;common-lisp&#39;</span>

      <span class="n">filenames</span> <span class="s1">&#39;*.cl&#39;</span><span class="p">,</span> <span class="s1">&#39;*.lisp&#39;</span><span class="p">,</span> <span class="s1">&#39;*.el&#39;</span> <span class="c1"># used for Elisp too</span>
      <span class="n">mimetypes</span> <span class="s1">&#39;text/x-common-lisp&#39;</span>

      <span class="c1"># 638 functions</span>
      <span class="no">BUILTIN_FUNCTIONS</span> <span class="o">=</span> <span class="no">Set</span><span class="nf">.new</span> <span class="sx">%w(
        &lt; &lt;= = &gt; &gt;= - / /= * + 1- 1+ abort abs acons acos acosh add-method
        adjoin adjustable-array-p adjust-array allocate-instance
        alpha-char-p alphanumericp append apply apropos apropos-list
        aref arithmetic-error-operands arithmetic-error-operation
        array-dimension array-dimensions array-displacement
        array-element-type array-has-fill-pointer-p array-in-bounds-p
        arrayp array-rank array-row-major-index array-total-size
        ash asin asinh assoc assoc-if assoc-if-not atan atanh atom
        bit bit-and bit-andc1 bit-andc2 bit-eqv bit-ior bit-nand
        bit-nor bit-not bit-orc1 bit-orc2 bit-vector-p bit-xor boole
        both-case-p boundp break broadcast-stream-streams butlast
        byte byte-position byte-size caaaar caaadr caaar caadar
        caaddr caadr caar cadaar cadadr cadar caddar cadddr caddr
        cadr call-next-method car cdaaar cdaadr cdaar cdadar cdaddr
        cdadr cdar cddaar cddadr cddar cdddar cddddr cdddr cddr cdr
        ceiling cell-error-name cerror change-class char char&lt; char&lt;=
        char= char&gt; char&gt;= char/= character characterp char-code
        char-downcase char-equal char-greaterp char-int char-lessp
        char-name char-not-equal char-not-greaterp char-not-lessp
        char-upcase cis class-name class-of clear-input clear-output
        close clrhash code-char coerce compile compiled-function-p
        compile-file compile-file-pathname compiler-macro-function
        complement complex complexp compute-applicable-methods
        compute-restarts concatenate concatenated-stream-streams conjugate
        cons consp constantly constantp continue copy-alist copy-list
        copy-pprint-dispatch copy-readtable copy-seq copy-structure
        copy-symbol copy-tree cos cosh count count-if count-if-not
        decode-float decode-universal-time delete delete-duplicates
        delete-file delete-if delete-if-not delete-package denominator
        deposit-field describe describe-object digit-char digit-char-p
        directory directory-namestring disassemble documentation dpb
        dribble echo-stream-input-stream echo-stream-output-stream
        ed eighth elt encode-universal-time endp enough-namestring
        ensure-directories-exist ensure-generic-function eq
        eql equal equalp error eval evenp every exp export expt
        fboundp fceiling fdefinition ffloor fifth file-author
        file-error-pathname file-length file-namestring file-position
        file-string-length file-write-date fill fill-pointer find
        find-all-symbols find-class find-if find-if-not find-method
        find-package find-restart find-symbol finish-output first
        float float-digits floatp float-precision float-radix
        float-sign floor fmakunbound force-output format fourth
        fresh-line fround ftruncate funcall function-keywords
        function-lambda-expression functionp gcd gensym gentemp get
        get-decoded-time get-dispatch-macro-character getf gethash
        get-internal-real-time get-internal-run-time get-macro-character
        get-output-stream-string get-properties get-setf-expansion
        get-universal-time graphic-char-p hash-table-count hash-table-p
        hash-table-rehash-size hash-table-rehash-threshold
        hash-table-size hash-table-test host-namestring identity
        imagpart import initialize-instance input-stream-p inspect
        integer-decode-float integer-length integerp interactive-stream-p
        intern intersection invalid-method-error invoke-debugger
        invoke-restart invoke-restart-interactively isqrt keywordp
        last lcm ldb ldb-test ldiff length lisp-implementation-type
        lisp-implementation-version list list* list-all-packages listen
        list-length listp load load-logical-pathname-translations
        log logand logandc1 logandc2 logbitp logcount logeqv
        logical-pathname logical-pathname-translations logior
        lognand lognor lognot logorc1 logorc2 logtest logxor
        long-site-name lower-case-p machine-instance machine-type
        machine-version macroexpand macroexpand-1 macro-function
        make-array make-broadcast-stream make-concatenated-stream
        make-condition make-dispatch-macro-character make-echo-stream
        make-hash-table make-instance make-instances-obsolete make-list
        make-load-form make-load-form-saving-slots make-package
        make-pathname make-random-state make-sequence make-string
        make-string-input-stream make-string-output-stream make-symbol
        make-synonym-stream make-two-way-stream makunbound map mapc
        mapcan mapcar mapcon maphash map-into mapl maplist mask-field
        max member member-if member-if-not merge merge-pathnames
        method-combination-error method-qualifiers min minusp mismatch mod
        muffle-warning name-char namestring nbutlast nconc next-method-p
        nintersection ninth no-applicable-method no-next-method not notany
        notevery nreconc nreverse nset-difference nset-exclusive-or
        nstring-capitalize nstring-downcase nstring-upcase nsublis
        nsubst nsubst-if nsubst-if-not nsubstitute nsubstitute-if
        nsubstitute-if-not nth nthcdr null numberp numerator nunion
        oddp open open-stream-p output-stream-p package-error-package
        package-name package-nicknames packagep package-shadowing-symbols
        package-used-by-list package-use-list pairlis parse-integer
        parse-namestring pathname pathname-device pathname-directory
        pathname-host pathname-match-p pathname-name pathnamep
        pathname-type pathname-version peek-char phase plusp
        position position-if position-if-not pprint pprint-dispatch
        pprint-fill pprint-indent pprint-linear pprint-newline pprint-tab
        pprint-tabular prin1 prin1-to-string princ princ-to-string print
        print-object probe-file proclaim provide random random-state-p
        rassoc rassoc-if rassoc-if-not rational rationalize rationalp
        read read-byte read-char read-char-no-hang read-delimited-list
        read-from-string read-line read-preserving-whitespace
        read-sequence readtable-case readtablep realp realpart
        reduce reinitialize-instance rem remhash remove
        remove-duplicates remove-if remove-if-not remove-method
        remprop rename-file rename-package replace require rest
        restart-name revappend reverse room round row-major-aref
        rplaca rplacd sbit scale-float schar search second set
        set-difference set-dispatch-macro-character set-exclusive-or
        set-macro-character set-pprint-dispatch set-syntax-from-char
        seventh shadow shadowing-import shared-initialize
        short-site-name signal signum simple-bit-vector-p
        simple-condition-format-arguments simple-condition-format-control
        simple-string-p simple-vector-p sin sinh sixth sleep slot-boundp
        slot-exists-p slot-makunbound slot-missing slot-unbound slot-value
        software-type software-version some sort special-operator-p
        sqrt stable-sort standard-char-p store-value stream-element-type
        stream-error-stream stream-external-format streamp string string&lt;
        string&lt;= string= string&gt; string&gt;= string/= string-capitalize
        string-downcase string-equal string-greaterp string-left-trim
        string-lessp string-not-equal string-not-greaterp string-not-lessp
        stringp string-right-trim string-trim string-upcase sublis subseq
        subsetp subst subst-if subst-if-not substitute substitute-if
        substitute-if-not subtypepsvref sxhash symbol-function
        symbol-name symbolp symbol-package symbol-plist symbol-value
        synonym-stream-symbol syntax: tailp tan tanh tenth terpri third
        translate-logical-pathname translate-pathname tree-equal truename
        truncate two-way-stream-input-stream two-way-stream-output-stream
        type-error-datum type-error-expected-type type-of
        typep unbound-slot-instance unexport unintern union
        unread-char unuse-package update-instance-for-different-class
        update-instance-for-redefined-class upgraded-array-element-type
        upgraded-complex-part-type upper-case-p use-package
        user-homedir-pathname use-value values values-list vector vectorp
        vector-pop vector-push vector-push-extend warn wild-pathname-p
        write write-byte write-char write-line write-sequence write-string
        write-to-string yes-or-no-p y-or-n-p zerop
      )</span><span class="nf">.freeze</span>

      <span class="no">SPECIAL_FORMS</span> <span class="o">=</span> <span class="no">Set</span><span class="nf">.new</span> <span class="sx">%w(
        block catch declare eval-when flet function go if labels lambda
        let let* load-time-value locally macrolet multiple-value-call
        multiple-value-prog1 progn progv quote return-from setq
        symbol-macrolet tagbody the throw unwind-protect
      )</span>

      <span class="no">MACROS</span> <span class="o">=</span> <span class="no">Set</span><span class="nf">.new</span> <span class="sx">%w(
        and assert call-method case ccase check-type cond ctypecase decf
        declaim defclass defconstant defgeneric define-compiler-macro
        define-condition define-method-combination define-modify-macro
        define-setf-expander define-symbol-macro defmacro defmethod
        defpackage defparameter defsetf defstruct deftype defun defvar
        destructuring-bind do do* do-all-symbols do-external-symbols
        dolist do-symbols dotimes ecase etypecase formatter
        handler-bind handler-case ignore-errors incf in-package
        lambda loop loop-finish make-method multiple-value-bind
        multiple-value-list multiple-value-setq nth-value or pop
        pprint-exit-if-list-exhausted pprint-logical-block pprint-pop
        print-unreadable-object prog prog* prog1 prog2 psetf psetq
        push pushnew remf restart-bind restart-case return rotatef
        setf shiftf step time trace typecase unless untrace when
        with-accessors with-compilation-unit with-condition-restarts
        with-hash-table-iterator with-input-from-string with-open-file
        with-open-stream with-output-to-string with-package-iterator
        with-simple-restart with-slots with-standard-io-syntax
      )</span>

      <span class="no">LAMBDA_LIST_KEYWORDS</span> <span class="o">=</span> <span class="no">Set</span><span class="nf">.new</span> <span class="sx">%w(
        &amp;allow-other-keys &amp;aux &amp;body &amp;environment &amp;key &amp;optional &amp;rest
        &amp;whole
      )</span>

      <span class="no">DECLARATIONS</span> <span class="o">=</span> <span class="no">Set</span><span class="nf">.new</span> <span class="sx">%w(
        dynamic-extent ignore optimize ftype inline special ignorable
        notinline type
      )</span>

      <span class="no">BUILTIN_TYPES</span> <span class="o">=</span> <span class="no">Set</span><span class="nf">.new</span> <span class="sx">%w(
        atom boolean base-char base-string bignum bit compiled-function
        extended-char fixnum keyword nil signed-byte short-float
        single-float double-float long-float simple-array
        simple-base-string simple-bit-vector simple-string simple-vector
        standard-char unsigned-byte

        arithmetic-error cell-error condition control-error
        division-by-zero end-of-file error file-error
        floating-point-inexact floating-point-overflow
        floating-point-underflow floating-point-invalid-operation
        parse-error package-error print-not-readable program-error
        reader-error serious-condition simple-condition simple-error
        simple-type-error simple-warning stream-error storage-condition
        style-warning type-error unbound-variable unbound-slot
        undefined-function warning
      )</span>

      <span class="no">BUILTIN_CLASSES</span> <span class="o">=</span> <span class="no">Set</span><span class="nf">.new</span> <span class="sx">%w(
        array broadcast-stream bit-vector built-in-class character
        class complex concatenated-stream cons echo-stream file-stream
        float function generic-function hash-table integer list
        logical-pathname method-combination method null number package
        pathname ratio rational readtable real random-state restart
        sequence standard-class standard-generic-function standard-method
        standard-object string-stream stream string structure-class
        structure-object symbol synonym-stream t two-way-stream vector
      )</span>

      <span class="n">postprocess</span> <span class="s1">&#39;Name.Variable&#39;</span> <span class="k">do</span> <span class="o">|</span><span class="n">tok</span><span class="p">,</span> <span class="n">val</span><span class="o">|</span>
        <span class="n">tok</span> <span class="o">=</span> <span class="k">if</span> <span class="no">BUILTIN_FUNCTIONS</span><span class="nf">.include?</span> <span class="n">val</span>
          <span class="s1">&#39;Name.Builtin&#39;</span>
        <span class="k">elsif</span> <span class="no">SPECIAL_FORMS</span><span class="nf">.include?</span> <span class="n">val</span>
          <span class="s1">&#39;Keyword&#39;</span>
        <span class="k">elsif</span> <span class="no">MACROS</span><span class="nf">.include?</span> <span class="n">val</span>
          <span class="s1">&#39;Name.Builtin&#39;</span>
        <span class="k">elsif</span> <span class="no">LAMBDA_LIST_KEYWORDS</span><span class="nf">.include?</span> <span class="n">val</span>
          <span class="s1">&#39;Keyword&#39;</span>
        <span class="k">elsif</span> <span class="no">DECLARATIONS</span><span class="nf">.include?</span> <span class="n">val</span>
          <span class="s1">&#39;Keyword&#39;</span>
        <span class="k">elsif</span> <span class="no">BUILTIN_TYPES</span><span class="nf">.include?</span> <span class="n">val</span>
          <span class="s1">&#39;Keyword.Type&#39;</span>
        <span class="k">elsif</span> <span class="no">BUILTIN_CLASSES</span><span class="nf">.include?</span> <span class="n">val</span>
          <span class="s1">&#39;Name.Class&#39;</span>
        <span class="k">else</span>
          <span class="s1">&#39;Name.Variable&#39;</span>
        <span class="k">end</span>

        <span class="n">token</span> <span class="n">tok</span><span class="p">,</span> <span class="n">val</span>
      <span class="k">end</span>

      <span class="n">nonmacro</span> <span class="o">=</span> <span class="sr">/\\.|[a-zA-Z0-9!$%&amp;*+-\/&lt;=&gt;?@\[\]^_{}~]/</span>
      <span class="n">constituent</span> <span class="o">=</span> <span class="sr">/</span><span class="si">#{</span><span class="n">nonmacro</span><span class="si">}</span><span class="sr">|[#.:]/</span>
      <span class="n">terminated</span> <span class="o">=</span> <span class="sr">/(?=[ &quot;&#39;()\n,;`])/</span> <span class="c1"># whitespace or terminating macro chars</span>
      <span class="n">symbol</span> <span class="o">=</span> <span class="sr">/(\|[^\|]+\||</span><span class="si">#{</span><span class="n">nonmacro</span><span class="si">}#{</span><span class="n">constituent</span><span class="si">}</span><span class="sr">*)/</span>

      <span class="n">state</span> <span class="ss">:root</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">/\s+/m</span><span class="p">,</span> <span class="s1">&#39;Text&#39;</span>
        <span class="n">rule</span> <span class="sr">/;.*$/</span><span class="p">,</span> <span class="s1">&#39;Comment.Single&#39;</span>
        <span class="n">rule</span> <span class="sr">/#\|/</span><span class="p">,</span> <span class="s1">&#39;Comment.Multiline&#39;</span><span class="p">,</span> <span class="ss">:multiline_comment</span>

        <span class="c1"># encoding comment</span>
        <span class="n">rule</span> <span class="sr">/#\d*Y.*$/</span><span class="p">,</span> <span class="s1">&#39;Comment.Special&#39;</span>
        <span class="n">rule</span> <span class="sr">/&quot;(\\.|[^&quot;\\])*&quot;/</span><span class="p">,</span> <span class="s1">&#39;Literal.String&#39;</span>

        <span class="n">rule</span> <span class="sr">/[:&#39;]</span><span class="si">#{</span><span class="n">symbol</span><span class="si">}</span><span class="sr">/</span><span class="p">,</span> <span class="s1">&#39;Literal.String.Symbol&#39;</span>
        <span class="n">rule</span> <span class="sr">/[&#39;`]/</span><span class="p">,</span> <span class="s1">&#39;Operator&#39;</span>

        <span class="c1"># numbers</span>
        <span class="n">rule</span> <span class="sr">/[-+]?\d+\.?</span><span class="si">#{</span><span class="n">terminated</span><span class="si">}</span><span class="sr">/</span><span class="p">,</span> <span class="s1">&#39;Literal.Number.Integer&#39;</span>
        <span class="n">rule</span> <span class="sr">%r([-+]?</span><span class="se">\d</span><span class="sr">+/</span><span class="se">\d</span><span class="sr">+</span><span class="si">#{</span><span class="n">terminated</span><span class="si">}</span><span class="sr">)</span><span class="p">,</span> <span class="s1">&#39;Literal.Number.Integer&#39;</span>
        <span class="n">rule</span> <span class="sr">%r(
          [-+]?
          (</span><span class="se">\d</span><span class="sr">*</span><span class="se">\.\d</span><span class="sr">+([defls][-+]?</span><span class="se">\d</span><span class="sr">+)?
          |</span><span class="se">\d</span><span class="sr">+(</span><span class="se">\.\d</span><span class="sr">*)?[defls][-+]?</span><span class="se">\d</span><span class="sr">+)
          </span><span class="si">#{</span><span class="n">terminated</span><span class="si">}</span><span class="sr">
        )x</span><span class="p">,</span> <span class="s1">&#39;Literal.Number.Float&#39;</span>

        <span class="c1"># sharpsign strings and characters</span>
        <span class="n">rule</span> <span class="sr">/#\\.</span><span class="si">#{</span><span class="n">terminated</span><span class="si">}</span><span class="sr">/</span><span class="p">,</span> <span class="s1">&#39;Literal.String.Char&#39;</span>
        <span class="n">rule</span> <span class="sr">/#\\</span><span class="si">#{</span><span class="n">symbol</span><span class="si">}</span><span class="sr">/</span><span class="p">,</span> <span class="s1">&#39;Literal.String.Char&#39;</span>

        <span class="n">rule</span> <span class="sr">/#\(/</span><span class="p">,</span> <span class="s1">&#39;Operator&#39;</span><span class="p">,</span> <span class="ss">:root</span>

        <span class="c1"># bitstring</span>
        <span class="n">rule</span> <span class="sr">/#\d*\*[01]*/</span><span class="p">,</span> <span class="s1">&#39;Literal.Other&#39;</span>

        <span class="c1"># uninterned symbol</span>
        <span class="n">rule</span> <span class="sr">/#:</span><span class="si">#{</span><span class="n">symbol</span><span class="si">}</span><span class="sr">/</span><span class="p">,</span> <span class="s1">&#39;Literal.String.Symbol&#39;</span>

        <span class="c1"># read-time and load-time evaluation</span>
        <span class="n">rule</span> <span class="sr">/#[.,]/</span><span class="p">,</span> <span class="s1">&#39;Operator&#39;</span>

        <span class="c1"># function shorthand</span>
        <span class="n">rule</span> <span class="sr">/#&#39;/</span><span class="p">,</span> <span class="s1">&#39;Name.Function&#39;</span>

        <span class="c1"># binary rational</span>
        <span class="n">rule</span> <span class="sr">/#b[+-]?[01]+(\/[01]+)?/i</span><span class="p">,</span> <span class="s1">&#39;Literal.Number&#39;</span>

        <span class="c1"># octal rational</span>
        <span class="n">rule</span> <span class="sr">/#o[+-]?[0-7]+(\/[0-7]+)?/i</span><span class="p">,</span> <span class="s1">&#39;Literal.Number.Oct&#39;</span>

        <span class="c1"># hex rational</span>
        <span class="n">rule</span> <span class="sr">/#x[+-]?[0-9a-f]+(\/[0-9a-f]+)?/i</span><span class="p">,</span> <span class="s1">&#39;Literal.Number&#39;</span>

        <span class="c1"># complex</span>
        <span class="n">rule</span> <span class="sr">/(#c)(\()/i</span> <span class="k">do</span>
          <span class="n">group</span> <span class="s1">&#39;Literal.Number&#39;</span>
          <span class="n">group</span> <span class="s1">&#39;Punctuation&#39;</span>
          <span class="n">push</span> <span class="ss">:root</span>
        <span class="k">end</span>

        <span class="c1"># arrays and structures</span>
        <span class="n">rule</span> <span class="sr">/(#(?:\d+a|s))(\()/i</span> <span class="k">do</span>
          <span class="n">group</span> <span class="s1">&#39;Literal.Other&#39;</span>
          <span class="n">group</span> <span class="s1">&#39;Punctuation&#39;</span>
          <span class="n">push</span> <span class="ss">:root</span>
        <span class="k">end</span>

        <span class="c1"># path</span>
        <span class="n">rule</span> <span class="sr">/#p?&quot;(\\.|[^&quot;])*&quot;/i</span>

        <span class="c1"># reference</span>
        <span class="n">rule</span> <span class="sr">/#\d+[=#]/</span><span class="p">,</span> <span class="s1">&#39;Operator&#39;</span>

        <span class="c1"># read-time comment</span>
        <span class="n">rule</span> <span class="sr">/#+nil</span><span class="si">#{</span><span class="n">terminated</span><span class="si">}</span><span class="sr">\s*\(/</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span><span class="p">,</span> <span class="ss">:commented_form</span>

        <span class="c1"># read-time conditional</span>
        <span class="n">rule</span> <span class="sr">/#[+-]/</span><span class="p">,</span> <span class="s1">&#39;Operator&#39;</span>

        <span class="c1"># special operators that should have been parsed already</span>
        <span class="n">rule</span> <span class="sr">/(,@|,|\.)/</span><span class="p">,</span> <span class="s1">&#39;Operator&#39;</span>

        <span class="c1"># special constants</span>
        <span class="n">rule</span> <span class="sr">/(t|nil)</span><span class="si">#{</span><span class="n">terminated</span><span class="si">}</span><span class="sr">/</span><span class="p">,</span> <span class="s1">&#39;Name.Constant&#39;</span>

        <span class="c1"># functions and variables</span>
        <span class="c1"># note that these get filtered through in stream_tokens</span>
        <span class="n">rule</span> <span class="sr">/\*</span><span class="si">#{</span><span class="n">symbol</span><span class="si">}</span><span class="sr">\*/</span><span class="p">,</span> <span class="s1">&#39;Name.Variable.Global&#39;</span>
        <span class="n">rule</span> <span class="n">symbol</span><span class="p">,</span> <span class="s1">&#39;Name.Variable&#39;</span>

        <span class="n">rule</span> <span class="sr">/\(/</span><span class="p">,</span> <span class="s1">&#39;Punctuation&#39;</span><span class="p">,</span> <span class="ss">:root</span>
        <span class="n">rule</span> <span class="sr">/\)/</span><span class="p">,</span> <span class="s1">&#39;Punctuation&#39;</span> <span class="k">do</span>
          <span class="k">if</span> <span class="n">stack</span><span class="nf">.empty?</span>
            <span class="n">token</span> <span class="s1">&#39;Error&#39;</span>
          <span class="k">else</span>
            <span class="n">token</span> <span class="s1">&#39;Punctuation&#39;</span>
            <span class="n">pop!</span>
          <span class="k">end</span>
        <span class="k">end</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:multiline_comment</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">/#\|/</span><span class="p">,</span> <span class="s1">&#39;Comment.Multiline&#39;</span><span class="p">,</span> <span class="ss">:multiline_comment</span>
        <span class="n">rule</span> <span class="sr">/\|#/</span><span class="p">,</span> <span class="s1">&#39;Comment.Multiline&#39;</span><span class="p">,</span> <span class="ss">:pop!</span>
        <span class="n">rule</span> <span class="sr">/[^\|#]+/</span><span class="p">,</span> <span class="s1">&#39;Comment.Multiline&#39;</span>
        <span class="n">rule</span> <span class="sr">/[\|#]/</span><span class="p">,</span> <span class="s1">&#39;Comment.Multiline&#39;</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:commented_form</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">/\(/</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span><span class="p">,</span> <span class="ss">:commented_form</span>
        <span class="n">rule</span> <span class="sr">/\)/</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span><span class="p">,</span> <span class="ss">:pop!</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="k">module</span> <span class="nn">Rouge</span>
  <span class="k">module</span> <span class="nn">Lexers</span>
    <span class="k">class </span><span class="nc">Cpp</span> <span class="o">&lt;</span> <span class="no">RegexLexer</span>
      <span class="n">desc</span> <span class="s2">&quot;The C++ programming language&quot;</span>

      <span class="n">tag</span> <span class="s1">&#39;cpp&#39;</span>
      <span class="n">aliases</span> <span class="s1">&#39;c++&#39;</span>
      <span class="c1"># the many varied filenames of c++ source files...</span>
      <span class="n">filenames</span> <span class="s1">&#39;*.cpp&#39;</span><span class="p">,</span> <span class="s1">&#39;*.hpp&#39;</span><span class="p">,</span>
                <span class="s1">&#39;*.c++&#39;</span><span class="p">,</span> <span class="s1">&#39;*.h++&#39;</span><span class="p">,</span>
                <span class="s1">&#39;*.cc&#39;</span><span class="p">,</span>  <span class="s1">&#39;*.hh&#39;</span><span class="p">,</span>
                <span class="s1">&#39;*.cxx&#39;</span><span class="p">,</span> <span class="s1">&#39;*.hxx&#39;</span>
      <span class="n">mimetypes</span> <span class="s1">&#39;text/x-c++hdr&#39;</span><span class="p">,</span> <span class="s1">&#39;text/x-c++src&#39;</span>

      <span class="n">keywords</span> <span class="o">=</span> <span class="sx">%w(
        asm auto break case catch const const_cast continue
        default delete do dynamic_cast else enum explicit export
        extern for friend goto if mutable namespace new operator
        private protected public register reinterpret_cast return
        restrict sizeof static static_cast struct switch template
        this throw throws try typedef typeid typename union using
        volatile virtual while
      )</span>

      <span class="n">keywords_type</span> <span class="o">=</span> <span class="sx">%w(
        bool int long float short double char unsigned signed void wchar_t
      )</span>

      <span class="n">__reserved</span> <span class="o">=</span> <span class="sx">%w(
        asm int8 based except int16 stdcall cdecl fastcall int32 declspec
        finally int64 try leave wchar_t w64 virtual_inheritance uuidof
        unaligned super single_inheritance raise noop multiple_inheritance
        m128i m128d m128 m64 interface identifier forceinline event assume
      )</span>

      <span class="c1"># optional comments or whitespace</span>
      <span class="n">ws</span> <span class="o">=</span> <span class="sr">%r((?:</span><span class="se">\s</span><span class="sr">|//.*?</span><span class="se">\n</span><span class="sr">|/[*].*?[*]/)+)</span>
      <span class="nb">id</span> <span class="o">=</span> <span class="sr">/[a-zA-Z_][a-zA-Z0-9]*/</span>

      <span class="n">state</span> <span class="ss">:whitespace</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">/^#if\s+0/</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span><span class="p">,</span> <span class="ss">:if_0</span>
        <span class="n">rule</span> <span class="sr">/^#/</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span><span class="p">,</span> <span class="ss">:macro</span>
        <span class="n">rule</span> <span class="sr">/^</span><span class="si">#{</span><span class="n">ws</span><span class="si">}</span><span class="sr">#if\s+0\b/</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span><span class="p">,</span> <span class="ss">:if_0</span>
        <span class="n">rule</span> <span class="sr">/^</span><span class="si">#{</span><span class="n">ws</span><span class="si">}</span><span class="sr">#/</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span><span class="p">,</span> <span class="ss">:macro</span>
        <span class="n">rule</span> <span class="sr">/\s+/m</span><span class="p">,</span> <span class="s1">&#39;Text&#39;</span>
        <span class="n">rule</span> <span class="sr">/\\\n/</span><span class="p">,</span> <span class="s1">&#39;Text&#39;</span>
        <span class="n">rule</span> <span class="sr">%r(/(</span><span class="se">\\\n</span><span class="sr">)?/(</span><span class="se">\n</span><span class="sr">|(.|</span><span class="se">\n</span><span class="sr">)*?[^</span><span class="se">\\</span><span class="sr">]</span><span class="se">\n</span><span class="sr">))</span><span class="p">,</span> <span class="s1">&#39;Comment.Single&#39;</span>
        <span class="n">rule</span> <span class="sr">%r(/(</span><span class="se">\\\n</span><span class="sr">)?[*](.|</span><span class="se">\n</span><span class="sr">)*?[*](</span><span class="se">\\\n</span><span class="sr">)?/)</span><span class="p">,</span> <span class="s1">&#39;Comment.Multiline&#39;</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:whitespace</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">/^#if\s+0/</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span><span class="p">,</span> <span class="ss">:if_0</span>
        <span class="n">rule</span> <span class="sr">/^#/</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span><span class="p">,</span> <span class="ss">:macro</span>
        <span class="n">rule</span> <span class="sr">/^</span><span class="si">#{</span><span class="n">ws</span><span class="si">}</span><span class="sr">#if\s+0\b/</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span><span class="p">,</span> <span class="ss">:if_0</span>
        <span class="n">rule</span> <span class="sr">/^</span><span class="si">#{</span><span class="n">ws</span><span class="si">}</span><span class="sr">#/</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span><span class="p">,</span> <span class="ss">:macro</span>
        <span class="n">rule</span> <span class="sr">/\s+/m</span><span class="p">,</span> <span class="s1">&#39;Text&#39;</span>
        <span class="n">rule</span> <span class="sr">/\\\n/</span><span class="p">,</span> <span class="s1">&#39;Text&#39;</span>
        <span class="n">rule</span> <span class="sr">%r(/(</span><span class="se">\\\n</span><span class="sr">)?/(</span><span class="se">\n</span><span class="sr">|(.|</span><span class="se">\n</span><span class="sr">)*?[^</span><span class="se">\\</span><span class="sr">]</span><span class="se">\n</span><span class="sr">))</span><span class="p">,</span> <span class="s1">&#39;Comment.Single&#39;</span>
        <span class="n">rule</span> <span class="sr">%r(/(</span><span class="se">\\\n</span><span class="sr">)?[*](.|</span><span class="se">\n</span><span class="sr">)*?[*](</span><span class="se">\\\n</span><span class="sr">)?/)</span><span class="p">,</span> <span class="s1">&#39;Comment.Multiline&#39;</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:whitespace</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">/^#if\s+0/</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span><span class="p">,</span> <span class="ss">:if_0</span>
        <span class="n">rule</span> <span class="sr">/^#/</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span><span class="p">,</span> <span class="ss">:macro</span>
        <span class="n">rule</span> <span class="sr">/^</span><span class="si">#{</span><span class="n">ws</span><span class="si">}</span><span class="sr">#if\s+0\b/</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span><span class="p">,</span> <span class="ss">:if_0</span>
        <span class="n">rule</span> <span class="sr">/^</span><span class="si">#{</span><span class="n">ws</span><span class="si">}</span><span class="sr">#/</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span><span class="p">,</span> <span class="ss">:macro</span>
        <span class="n">rule</span> <span class="sr">/\s+/m</span><span class="p">,</span> <span class="s1">&#39;Text&#39;</span>
        <span class="n">rule</span> <span class="sr">/\\\n/</span><span class="p">,</span> <span class="s1">&#39;Text&#39;</span>
        <span class="n">rule</span> <span class="sr">%r(/(</span><span class="se">\\\n</span><span class="sr">)?/(</span><span class="se">\n</span><span class="sr">|(.|</span><span class="se">\n</span><span class="sr">)*?[^</span><span class="se">\\</span><span class="sr">]</span><span class="se">\n</span><span class="sr">))</span><span class="p">,</span> <span class="s1">&#39;Comment.Single&#39;</span>
        <span class="n">rule</span> <span class="sr">%r(/(</span><span class="se">\\\n</span><span class="sr">)?[*](.|</span><span class="se">\n</span><span class="sr">)*?[*](</span><span class="se">\\\n</span><span class="sr">)?/)</span><span class="p">,</span> <span class="s1">&#39;Comment.Multiline&#39;</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:whitespace</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">/^#if\s+0/</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span><span class="p">,</span> <span class="ss">:if_0</span>
        <span class="n">rule</span> <span class="sr">/^#/</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span><span class="p">,</span> <span class="ss">:macro</span>
        <span class="n">rule</span> <span class="sr">/^</span><span class="si">#{</span><span class="n">ws</span><span class="si">}</span><span class="sr">#if\s+0\b/</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span><span class="p">,</span> <span class="ss">:if_0</span>
        <span class="n">rule</span> <span class="sr">/^</span><span class="si">#{</span><span class="n">ws</span><span class="si">}</span><span class="sr">#/</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span><span class="p">,</span> <span class="ss">:macro</span>
        <span class="n">rule</span> <span class="sr">/\s+/m</span><span class="p">,</span> <span class="s1">&#39;Text&#39;</span>
        <span class="n">rule</span> <span class="sr">/\\\n/</span><span class="p">,</span> <span class="s1">&#39;Text&#39;</span>
        <span class="n">rule</span> <span class="sr">%r(/(</span><span class="se">\\\n</span><span class="sr">)?/(</span><span class="se">\n</span><span class="sr">|(.|</span><span class="se">\n</span><span class="sr">)*?[^</span><span class="se">\\</span><span class="sr">]</span><span class="se">\n</span><span class="sr">))</span><span class="p">,</span> <span class="s1">&#39;Comment.Single&#39;</span>
        <span class="n">rule</span> <span class="sr">%r(/(</span><span class="se">\\\n</span><span class="sr">)?[*](.|</span><span class="se">\n</span><span class="sr">)*?[*](</span><span class="se">\\\n</span><span class="sr">)?/)</span><span class="p">,</span> <span class="s1">&#39;Comment.Multiline&#39;</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:root</span> <span class="k">do</span>
        <span class="n">mixin</span> <span class="ss">:whitespace</span>

        <span class="n">rule</span> <span class="sr">/L?&quot;/</span><span class="p">,</span> <span class="s1">&#39;Literal.String&#39;</span><span class="p">,</span> <span class="ss">:string</span>
        <span class="n">rule</span> <span class="sr">%r(L?&#39;(</span><span class="se">\\</span><span class="sr">.|</span><span class="se">\\</span><span class="sr">[0-7]{1,3}|</span><span class="se">\\</span><span class="sr">x[a-f0-9]{1,2}|[^</span><span class="se">\\</span><span class="sr">&#39;</span><span class="se">\n</span><span class="sr">])&#39;)i</span><span class="p">,</span> <span class="s1">&#39;Literal.String.Char&#39;</span>
        <span class="n">rule</span> <span class="sr">%r((</span><span class="se">\d</span><span class="sr">+</span><span class="se">\.\d</span><span class="sr">*|</span><span class="se">\.\d</span><span class="sr">+|</span><span class="se">\d</span><span class="sr">+)[e][+-]?</span><span class="se">\d</span><span class="sr">+[lu]*)i</span><span class="p">,</span> <span class="s1">&#39;Literal.Number.Float&#39;</span>
        <span class="n">rule</span> <span class="sr">/0x[0-9a-f]+[lu]*/i</span><span class="p">,</span> <span class="s1">&#39;Literal.Number.Hex&#39;</span>
        <span class="n">rule</span> <span class="sr">/0[0-7]+[lu]*/i</span><span class="p">,</span> <span class="s1">&#39;Literal.Number.Oct&#39;</span>
        <span class="n">rule</span> <span class="sr">/\d+[lu]*/i</span><span class="p">,</span> <span class="s1">&#39;Literal.Number.Integer&#39;</span>
        <span class="n">rule</span> <span class="sr">%r(</span><span class="se">\*</span><span class="sr">/)</span><span class="p">,</span> <span class="s1">&#39;Error&#39;</span>
        <span class="n">rule</span> <span class="sr">%r([~!%^&amp;*+=</span><span class="se">\|</span><span class="sr">?:&lt;&gt;/-])</span><span class="p">,</span> <span class="s1">&#39;Operator&#39;</span>
        <span class="n">rule</span> <span class="sr">/[()\[\],.;{}]/</span><span class="p">,</span> <span class="s1">&#39;Punctuation&#39;</span>

        <span class="n">rule</span> <span class="sr">/(?:</span><span class="si">#{</span><span class="n">keywords</span><span class="nf">.join</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">)</span><span class="si">}</span><span class="sr">)\b/</span><span class="p">,</span> <span class="s1">&#39;Keyword&#39;</span>
        <span class="n">rule</span> <span class="sr">/class\b/</span><span class="p">,</span> <span class="s1">&#39;Keyword&#39;</span><span class="p">,</span> <span class="ss">:classname</span>
        <span class="n">rule</span> <span class="sr">/(?:</span><span class="si">#{</span><span class="n">keywords_type</span><span class="nf">.join</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">)</span><span class="si">}</span><span class="sr">)\b/</span><span class="p">,</span> <span class="s1">&#39;Keyword.Type&#39;</span>
        <span class="n">rule</span> <span class="sr">/(?:_{0,2}inline|naked|thread)\b/</span><span class="p">,</span> <span class="s1">&#39;Keyword.Reserved&#39;</span>
        <span class="n">rule</span> <span class="sr">/__(?:</span><span class="si">#{</span><span class="n">__reserved</span><span class="nf">.join</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">)</span><span class="si">}</span><span class="sr">)\b/</span><span class="p">,</span> <span class="s1">&#39;Keyoword.Reserved&#39;</span>
        <span class="c1"># Offload C++ extensions, http://offload.codeplay.com/</span>
        <span class="n">rule</span> <span class="sr">/(?:__offload|__blockingoffload|__outer)\b/</span><span class="p">,</span> <span class="s1">&#39;Keyword.Pseudo&#39;</span>

        <span class="n">rule</span> <span class="sr">/(true|false)\b/</span><span class="p">,</span> <span class="s1">&#39;Keyword.Constant&#39;</span>
        <span class="n">rule</span> <span class="sr">/NULL\b/</span><span class="p">,</span> <span class="s1">&#39;Name.Builtin&#39;</span>
        <span class="n">rule</span> <span class="sr">/</span><span class="si">#{</span><span class="nb">id</span><span class="si">}</span><span class="sr">:(?!:)/</span><span class="p">,</span> <span class="s1">&#39;Name.Label&#39;</span>
        <span class="n">rule</span> <span class="nb">id</span><span class="p">,</span> <span class="s1">&#39;Name&#39;</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:classname</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="nb">id</span><span class="p">,</span> <span class="s1">&#39;Name.Class&#39;</span><span class="p">,</span> <span class="ss">:pop!</span>

        <span class="c1"># template specification</span>
        <span class="n">rule</span> <span class="sr">/\s*(?=&gt;)/m</span><span class="p">,</span> <span class="s1">&#39;Text&#39;</span><span class="p">,</span> <span class="ss">:pop!</span>
        <span class="n">mixin</span> <span class="ss">:whitespace</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:string</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">/&quot;/</span><span class="p">,</span> <span class="s1">&#39;Literal.String&#39;</span><span class="p">,</span> <span class="ss">:pop!</span>
        <span class="n">rule</span> <span class="sr">/\\([\\abfnrtv&quot;&#39;]|x[a-fA-F0-9]{2,4}|[0-7]{1,3})/</span><span class="p">,</span> <span class="s1">&#39;Literal.String.Escape&#39;</span>
        <span class="n">rule</span> <span class="sr">/[^\\&quot;\n]+/</span><span class="p">,</span> <span class="s1">&#39;Literal.String&#39;</span>
        <span class="n">rule</span> <span class="sr">/\\\n/</span><span class="p">,</span> <span class="s1">&#39;Literal.String&#39;</span>
        <span class="n">rule</span> <span class="sr">/\\/</span><span class="p">,</span> <span class="s1">&#39;Literal.String&#39;</span> <span class="c1"># stray backslash</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:macro</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">%r([^/</span><span class="se">\n</span><span class="sr">]+)</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span>
        <span class="n">rule</span> <span class="sr">%r(/[*].*?[*]/)m</span><span class="p">,</span> <span class="s1">&#39;Comment.Multiliine&#39;</span>
        <span class="n">rule</span> <span class="sr">%r(//.*$)</span><span class="p">,</span> <span class="s1">&#39;Comment.Single&#39;</span>
        <span class="n">rule</span> <span class="sr">%r(/)</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span>
        <span class="n">rule</span> <span class="sr">/(?&lt;=\\)\n/</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span>
        <span class="n">rule</span> <span class="sr">/\n/</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span><span class="p">,</span> <span class="ss">:pop!</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:if_0</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">/^\s*#if.*?(?&lt;!\\)\n/</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span><span class="p">,</span> <span class="ss">:if_0</span>
        <span class="n">rule</span> <span class="sr">/^\s*#el(?:se|if).*\n/</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span><span class="p">,</span> <span class="ss">:pop!</span>
        <span class="n">rule</span> <span class="sr">/^\s*#endif.*?(?&lt;!\\)\n/</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span><span class="p">,</span> <span class="ss">:pop!</span>
        <span class="n">rule</span> <span class="sr">/.*?\n/</span><span class="p">,</span> <span class="s1">&#39;Comment&#39;</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="k">module</span> <span class="nn">Rouge</span>
  <span class="k">module</span> <span class="nn">Lexers</span>
    <span class="k">class </span><span class="nc">CSS</span> <span class="o">&lt;</span> <span class="no">RegexLexer</span>
      <span class="n">desc</span> <span class="s2">&quot;Cascading Style Sheets, used to style web pages&quot;</span>

      <span class="n">tag</span> <span class="s1">&#39;css&#39;</span>
      <span class="n">filenames</span> <span class="s1">&#39;*.css&#39;</span>
      <span class="n">mimetypes</span> <span class="s1">&#39;text/css&#39;</span>

      <span class="n">identifier</span> <span class="o">=</span> <span class="sr">/[a-zA-Z0-9_-]+/</span>
      <span class="n">number</span> <span class="o">=</span> <span class="sr">/-?(?:[0-9]+(\.[0-9]+)?|\.[0-9]+)/</span>

      <span class="k">def </span><span class="nc">self</span><span class="o">.</span><span class="nf">attributes</span>
        <span class="vi">@attributes</span> <span class="o">||=</span> <span class="no">Set</span><span class="nf">.new</span> <span class="sx">%w(
          azimuth background background-attachment background-color
          background-image background-position background-repeat
          border border-bottom border-bottom-color border-bottom-style
          border-bottom-width border-collapse border-color border-left
          border-left-color border-left-style border-left-width
          border-right border-right-color border-right-style
          border-right-width border-spacing border-style border-top
          border-top-color border-top-style border-top-width
          border-width bottom caption-side clear clip color content
          counter-increment counter-reset cue cue-after cue-before cursor
          direction display elevation empty-cells float font font-family
          font-size font-size-adjust font-stretch font-style font-variant
          font-weight height left letter-spacing line-height list-style
          list-style-image list-style-position list-style-type margin
          margin-bottom margin-left margin-right margin-top marker-offset
          marks max-height max-width min-height min-width opacity orphans
          outline outline-color outline-style outline-width overflow-x
          overflow-y padding padding-bottom padding-left padding-right
          padding-top page page-break-after page-break-before
          page-break-inside pause pause-after pause-before pitch
          pitch-range play-during position quotes richness right size
          speak speak-header speak-numeral speak-punctuation speech-rate
          src stress table-layout text-align text-decoration text-indent
          text-shadow text-transform top unicode-bidi vertical-align
          visibility voice-family volume white-space widows width
          word-spacing z-index
        )</span>
      <span class="k">end</span>

      <span class="k">def </span><span class="nc">self</span><span class="o">.</span><span class="nf">builtins</span>
        <span class="vi">@builtins</span> <span class="o">||=</span> <span class="no">Set</span><span class="nf">.new</span> <span class="sx">%w(
          above absolute always armenian aural auto avoid left bottom
          baseline behind below bidi-override blink block bold bolder
          both bottom capitalize center center-left center-right circle
          cjk-ideographic close-quote collapse condensed continuous crop
          cross crosshair cursive dashed decimal decimal-leading-zero
          default digits disc dotted double e-resize embed expanded
          extra-condensed extra-expanded fantasy far-left far-right fast
          faster fixed georgian groove hebrew help hidden hide high higher
          hiragana hiragana-iroha icon inherit inline inline-table inset
          inside invert italic justify katakana katakana-iroha landscape
          large larger left left-side leftwards level lighter line-through
          list-item loud low lower lower-alpha lower-greek lower-roman
          lowercase ltr medium message-box middle mix monospace n-resize
          narrower ne-resize no-close-quote no-open-quote no-repeat none
          normal nowrap nw-resize oblique once open-quote outset outside
          overline pointer portrait px relative repeat repeat-x repeat-y
          rgb ridge right right-side rightwards s-resize sans-serif scroll
          se-resize semi-condensed semi-expanded separate serif show
          silent slow slower small-caps small-caption smaller soft solid
          spell-out square static status-bar super sw-resize table-caption
          table-cell table-column table-column-group table-footer-group
          table-header-group table-row table-row-group text text-bottom
          text-top thick thin top transparent ultra-condensed
          ultra-expanded underline upper-alpha upper-latin upper-roman
          uppercase url visible w-resize wait wider x-fast x-high x-large
          x-loud x-low x-small x-soft xx-large xx-small yes
        )</span>
      <span class="k">end</span>

      <span class="k">def </span><span class="nc">self</span><span class="o">.</span><span class="nf">constants</span>
        <span class="vi">@constants</span> <span class="o">||=</span> <span class="no">Set</span><span class="nf">.new</span> <span class="sx">%w(
          indigo gold firebrick indianred yellow darkolivegreen
          darkseagreen mediumvioletred mediumorchid chartreuse
          mediumslateblue black springgreen crimson lightsalmon brown
          turquoise olivedrab cyan silver skyblue gray darkturquoise
          goldenrod darkgreen darkviolet darkgray lightpink teal
          darkmagenta lightgoldenrodyellow lavender yellowgreen thistle
          violet navy orchid blue ghostwhite honeydew cornflowerblue
          darkblue darkkhaki mediumpurple cornsilk red bisque slategray
          darkcyan khaki wheat deepskyblue darkred steelblue aliceblue
          gainsboro mediumturquoise floralwhite coral purple lightgrey
          lightcyan darksalmon beige azure lightsteelblue oldlace
          greenyellow royalblue lightseagreen mistyrose sienna lightcoral
          orangered navajowhite lime palegreen burlywood seashell
          mediumspringgreen fuchsia papayawhip blanchedalmond peru
          aquamarine white darkslategray ivory dodgerblue lemonchiffon
          chocolate orange forestgreen slateblue olive mintcream
          antiquewhite darkorange cadetblue moccasin limegreen saddlebrown
          darkslateblue lightskyblue deeppink plum aqua darkgoldenrod
          maroon sandybrown magenta tan rosybrown pink lightblue
          palevioletred mediumseagreen dimgray powderblue seagreen snow
          mediumblue midnightblue paleturquoise palegoldenrod whitesmoke
          darkorchid salmon lightslategray lawngreen lightgreen tomato
          hotpink lightyellow lavenderblush linen mediumaquamarine green
          blueviolet peachpuff
        )</span>
      <span class="k">end</span>

      <span class="c1"># source: http://www.w3.org/TR/CSS21/syndata.html#vendor-keyword-history</span>
      <span class="k">def </span><span class="nc">self</span><span class="o">.</span><span class="nf">vendor_prefixes</span>
        <span class="vi">@vendor_prefixes</span> <span class="o">||=</span> <span class="no">Set</span><span class="nf">.new</span> <span class="sx">%w(
          -ah- -atsc- -hp- -khtml- -moz- -ms- -o- -rim- -ro- -tc- -wap-
          -webkit- -xv- mso- prince-
        )</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:root</span> <span class="k">do</span>
        <span class="n">mixin</span> <span class="ss">:basics</span>
        <span class="n">rule</span> <span class="sr">/{/</span><span class="p">,</span> <span class="s1">&#39;Punctuation&#39;</span><span class="p">,</span> <span class="ss">:stanza</span>
        <span class="n">rule</span> <span class="sr">/:</span><span class="si">#{</span><span class="n">identifier</span><span class="si">}</span><span class="sr">/</span><span class="p">,</span> <span class="s1">&#39;Name.Decorator&#39;</span>
        <span class="n">rule</span> <span class="sr">/\.</span><span class="si">#{</span><span class="n">identifier</span><span class="si">}</span><span class="sr">/</span><span class="p">,</span> <span class="s1">&#39;Name.Class&#39;</span>
        <span class="n">rule</span> <span class="sr">/#</span><span class="si">#{</span><span class="n">identifier</span><span class="si">}</span><span class="sr">/</span><span class="p">,</span> <span class="s1">&#39;Name.Function&#39;</span>
        <span class="n">rule</span> <span class="sr">/@</span><span class="si">#{</span><span class="n">identifier</span><span class="si">}</span><span class="sr">/</span><span class="p">,</span> <span class="s1">&#39;Keyword&#39;</span><span class="p">,</span> <span class="ss">:at_rule</span>
        <span class="n">rule</span> <span class="n">identifier</span><span class="p">,</span> <span class="s1">&#39;Name.Tag&#39;</span>
        <span class="n">rule</span> <span class="sr">%r([~^*!%&amp;</span><span class="se">\[\]</span><span class="sr">()&lt;&gt;|+=@:;,./?-])</span><span class="p">,</span> <span class="s1">&#39;Operator&#39;</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:value</span> <span class="k">do</span>
        <span class="n">mixin</span> <span class="ss">:basics</span>
        <span class="n">rule</span> <span class="sr">/url\(.*?\)/</span><span class="p">,</span> <span class="s1">&#39;Literal.String.Other&#39;</span>
        <span class="n">rule</span> <span class="sr">/#[0-9a-f]{1,6}/i</span><span class="p">,</span> <span class="s1">&#39;Literal.Number&#39;</span> <span class="c1"># colors</span>
        <span class="n">rule</span> <span class="sr">/</span><span class="si">#{</span><span class="n">number</span><span class="si">}</span><span class="sr">(?:em|px|%|pt|pc|in|mm|m|ex|s)?\b/</span><span class="p">,</span> <span class="s1">&#39;Literal.Number&#39;</span>
        <span class="n">rule</span> <span class="sr">/[\[\]():\/.]/</span><span class="p">,</span> <span class="s1">&#39;Punctuation&#39;</span>
        <span class="n">rule</span> <span class="sr">/&quot;(\\\\|\\&quot;|[^&quot;])*&quot;/</span><span class="p">,</span> <span class="s1">&#39;Literal.String.Single&#39;</span>
        <span class="n">rule</span> <span class="sr">/&#39;(\\\\|\\&#39;|[^&#39;])*&#39;/</span><span class="p">,</span> <span class="s1">&#39;Literal.String.Double&#39;</span>
        <span class="n">rule</span><span class="p">(</span><span class="n">identifier</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span>
          <span class="k">if</span> <span class="nb">self</span><span class="nf">.class.constants.include?</span> <span class="n">m</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>
            <span class="n">token</span> <span class="s1">&#39;Name.Constant&#39;</span>
          <span class="k">elsif</span> <span class="nb">self</span><span class="nf">.class.builtins.include?</span> <span class="n">m</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>
            <span class="n">token</span> <span class="s1">&#39;Name.Builtin&#39;</span>
          <span class="k">else</span>
            <span class="n">token</span> <span class="s1">&#39;Name&#39;</span>
          <span class="k">end</span>
        <span class="k">end</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:at_rule</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">/{(?=\s*</span><span class="si">#{</span><span class="n">identifier</span><span class="si">}</span><span class="sr">\s*:)/m</span><span class="p">,</span> <span class="s1">&#39;Punctuation&#39;</span><span class="p">,</span> <span class="ss">:at_stanza</span>
        <span class="n">rule</span> <span class="sr">/{/</span><span class="p">,</span> <span class="s1">&#39;Punctuation&#39;</span><span class="p">,</span> <span class="ss">:at_body</span>
        <span class="n">rule</span> <span class="sr">/;/</span><span class="p">,</span> <span class="s1">&#39;Punctuation&#39;</span><span class="p">,</span> <span class="ss">:pop!</span>
        <span class="n">mixin</span> <span class="ss">:value</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:at_body</span> <span class="k">do</span>
        <span class="n">mixin</span> <span class="ss">:at_content</span>
        <span class="n">mixin</span> <span class="ss">:root</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:at_stanza</span> <span class="k">do</span>
        <span class="n">mixin</span> <span class="ss">:at_content</span>
        <span class="n">mixin</span> <span class="ss">:stanza</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:at_content</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">/}/</span> <span class="k">do</span>
          <span class="n">token</span> <span class="s1">&#39;Punctuation&#39;</span>
          <span class="n">pop!</span><span class="p">;</span> <span class="n">pop!</span>
        <span class="k">end</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:basics</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">/\s+/m</span><span class="p">,</span> <span class="s1">&#39;Text&#39;</span>
        <span class="n">rule</span> <span class="sr">%r(/</span><span class="se">\*</span><span class="sr">(?:.*?)</span><span class="se">\*</span><span class="sr">/)m</span><span class="p">,</span> <span class="s1">&#39;Comment&#39;</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:stanza</span> <span class="k">do</span>
        <span class="n">mixin</span> <span class="ss">:basics</span>
        <span class="n">rule</span> <span class="sr">/}/</span><span class="p">,</span> <span class="s1">&#39;Punctuation&#39;</span><span class="p">,</span> <span class="ss">:pop!</span>
        <span class="n">rule</span> <span class="sr">/(</span><span class="si">#{</span><span class="n">identifier</span><span class="si">}</span><span class="sr">)(\s*)(:)/m</span> <span class="k">do</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span>
          <span class="k">if</span> <span class="nb">self</span><span class="nf">.class.attributes.include?</span> <span class="n">m</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>
            <span class="n">group</span> <span class="s1">&#39;Name.Label&#39;</span>
          <span class="k">elsif</span> <span class="nb">self</span><span class="nf">.class.vendor_prefixes.any?</span> <span class="p">{</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span> <span class="n">m</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="nf">.start_with?</span><span class="p">(</span><span class="nb">p</span><span class="p">)</span> <span class="p">}</span>
            <span class="n">group</span> <span class="s1">&#39;Name.Label&#39;</span>
          <span class="k">else</span>
            <span class="n">group</span> <span class="s1">&#39;Name.Property&#39;</span>
          <span class="k">end</span>

          <span class="n">group</span> <span class="s1">&#39;Text&#39;</span>
          <span class="n">group</span> <span class="s1">&#39;Punctuation&#39;</span>

          <span class="n">push</span> <span class="ss">:stanza_value</span>
        <span class="k">end</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:stanza_value</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">/;/</span><span class="p">,</span> <span class="s1">&#39;Punctuation&#39;</span><span class="p">,</span> <span class="ss">:pop!</span>
        <span class="n">rule</span><span class="p">(</span><span class="sr">/(?=})/</span><span class="p">)</span> <span class="p">{</span> <span class="n">pop!</span> <span class="p">}</span>
        <span class="n">rule</span> <span class="sr">/!important\b/</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span>
        <span class="n">rule</span> <span class="sr">/^@.*?$/</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span>
        <span class="n">mixin</span> <span class="ss">:value</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="k">module</span> <span class="nn">Rouge</span>
  <span class="k">module</span> <span class="nn">Lexers</span>
    <span class="k">class </span><span class="nc">Diff</span> <span class="o">&lt;</span> <span class="no">RegexLexer</span>
      <span class="n">desc</span> <span class="s2">&quot;Lexes unified diffs or patches&quot;</span>

      <span class="n">tag</span> <span class="s1">&#39;diff&#39;</span>
      <span class="n">aliases</span> <span class="s1">&#39;patch&#39;</span><span class="p">,</span> <span class="s1">&#39;udiff&#39;</span>
      <span class="n">filenames</span> <span class="s1">&#39;*.diff&#39;</span><span class="p">,</span> <span class="s1">&#39;*.patch&#39;</span>
      <span class="n">mimetypes</span> <span class="s1">&#39;text/x-diff&#39;</span><span class="p">,</span> <span class="s1">&#39;text/x-patch&#39;</span>

      <span class="k">def </span><span class="nc">self</span><span class="o">.</span><span class="nf">analyze_text</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span>   <span class="k">if</span> <span class="n">text</span><span class="nf">.start_with?</span><span class="p">(</span><span class="s1">&#39;Index: &#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span>   <span class="k">if</span> <span class="n">text</span><span class="nf">.start_with?</span><span class="p">(</span><span class="s1">&#39;diff &#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="mi">0</span><span class="o">.</span><span class="mi">9</span> <span class="k">if</span> <span class="n">text</span> <span class="o">=~</span> <span class="sr">/\A---.*?\n\+\+\+/m</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:header</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">/^diff .*?\n(?=---|\+\+\+)/m</span><span class="p">,</span> <span class="s1">&#39;Generic.Heading&#39;</span>
        <span class="n">rule</span> <span class="sr">/^--- .*?\n/</span><span class="p">,</span> <span class="s1">&#39;Generic.Deleted&#39;</span>
        <span class="n">rule</span> <span class="sr">/^\+\+\+ .*?\n/</span><span class="p">,</span> <span class="s1">&#39;Generic.Inserted&#39;</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:diff</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">/@@ -\d+,\d+ \+\d+,\d+ @@.*?\n/</span><span class="p">,</span> <span class="s1">&#39;Generic.Heading&#39;</span>
        <span class="n">rule</span> <span class="sr">/^\+.*?\n/</span><span class="p">,</span> <span class="s1">&#39;Generic.Inserted&#39;</span>
        <span class="n">rule</span> <span class="sr">/^-.*?\n/</span><span class="p">,</span>  <span class="s1">&#39;Generic.Deleted&#39;</span>
        <span class="n">rule</span> <span class="sr">/^ .*?\n/</span><span class="p">,</span>  <span class="s1">&#39;Text&#39;</span>
        <span class="n">rule</span> <span class="sr">/^.*?\n/</span><span class="p">,</span>   <span class="s1">&#39;Error&#39;</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:root</span> <span class="k">do</span>
        <span class="n">mixin</span> <span class="ss">:header</span>
        <span class="n">mixin</span> <span class="ss">:diff</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="k">module</span> <span class="nn">Rouge</span>
  <span class="k">module</span> <span class="nn">Lexers</span>
    <span class="k">class </span><span class="nc">ERB</span> <span class="o">&lt;</span> <span class="no">TemplateLexer</span>
      <span class="n">desc</span> <span class="s2">&quot;Embedded ruby template files&quot;</span>

      <span class="n">tag</span> <span class="s1">&#39;erb&#39;</span>
      <span class="n">aliases</span> <span class="s1">&#39;eruby&#39;</span><span class="p">,</span> <span class="s1">&#39;rhtml&#39;</span>

      <span class="n">filenames</span> <span class="s1">&#39;*.erb&#39;</span><span class="p">,</span> <span class="s1">&#39;*.erubis&#39;</span><span class="p">,</span> <span class="s1">&#39;*.rhtml&#39;</span><span class="p">,</span> <span class="s1">&#39;*.eruby&#39;</span>

      <span class="k">def </span><span class="nc">self</span><span class="o">.</span><span class="nf">analyze_text</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">.</span><span class="mi">4</span> <span class="k">if</span> <span class="n">text</span> <span class="o">=~</span> <span class="sr">/&lt;%.*%&gt;/</span>
      <span class="k">end</span>

      <span class="k">def </span><span class="nf">initialize</span><span class="p">(</span><span class="n">opts</span><span class="o">=</span><span class="p">{})</span>
        <span class="vi">@ruby_lexer</span> <span class="o">=</span> <span class="no">Ruby</span><span class="nf">.new</span><span class="p">(</span><span class="n">opts</span><span class="p">)</span>

        <span class="k">super</span><span class="p">(</span><span class="n">opts</span><span class="p">)</span>
      <span class="k">end</span>

      <span class="n">start</span> <span class="k">do</span>
        <span class="n">parent</span><span class="nf">.reset!</span>
        <span class="vi">@ruby_lexer</span><span class="nf">.reset!</span>
      <span class="k">end</span>

      <span class="nb">open</span>  <span class="o">=</span> <span class="sr">/&lt;%%|&lt;%=|&lt;%#|&lt;%-|&lt;%/</span>
      <span class="n">close</span> <span class="o">=</span> <span class="sr">/%%&gt;|-%&gt;|%&gt;/</span>

      <span class="n">state</span> <span class="ss">:root</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">/&lt;%#/</span><span class="p">,</span> <span class="s1">&#39;Comment&#39;</span><span class="p">,</span> <span class="ss">:comment</span>

        <span class="n">rule</span> <span class="nb">open</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span><span class="p">,</span> <span class="ss">:ruby</span>

        <span class="n">rule</span> <span class="sr">/.+?(?=</span><span class="si">#{</span><span class="nb">open</span><span class="si">}</span><span class="sr">)|.+/m</span> <span class="k">do</span>
          <span class="n">delegate</span> <span class="n">parent</span>
        <span class="k">end</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:comment</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="n">close</span><span class="p">,</span> <span class="s1">&#39;Comment&#39;</span><span class="p">,</span> <span class="ss">:pop!</span>
        <span class="n">rule</span> <span class="sr">/.+(?=</span><span class="si">#{</span><span class="n">close</span><span class="si">}</span><span class="sr">)|.+/m</span><span class="p">,</span> <span class="s1">&#39;Comment&#39;</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:ruby</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="n">close</span><span class="p">,</span> <span class="s1">&#39;Comment.Preproc&#39;</span><span class="p">,</span> <span class="ss">:pop!</span>

        <span class="n">rule</span> <span class="sr">/.+?(?=</span><span class="si">#{</span><span class="n">close</span><span class="si">}</span><span class="sr">)|.+/m</span> <span class="k">do</span>
          <span class="n">delegate</span> <span class="vi">@ruby_lexer</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="k">module</span> <span class="nn">Rouge</span>
  <span class="k">module</span> <span class="nn">Lexers</span>
    <span class="k">class </span><span class="nc">Factor</span> <span class="o">&lt;</span> <span class="no">RegexLexer</span>
      <span class="n">desc</span> <span class="s2">&quot;Factor, the practical stack language (factorcode.org)&quot;</span>
      <span class="n">tag</span> <span class="s1">&#39;factor&#39;</span>
      <span class="n">filenames</span> <span class="s1">&#39;*.factor&#39;</span>
      <span class="n">mimetypes</span> <span class="s1">&#39;text/x-factor&#39;</span>

      <span class="k">def </span><span class="nc">self</span><span class="o">.</span><span class="nf">analyze_text</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">text</span><span class="nf">.shebang?</span> <span class="s1">&#39;factor&#39;</span>
      <span class="k">end</span>

      <span class="k">def </span><span class="nc">self</span><span class="o">.</span><span class="nf">builtins</span>
        <span class="vi">@builtins</span> <span class="o">||=</span> <span class="p">{}</span><span class="nf">.tap</span> <span class="k">do</span> <span class="o">|</span><span class="n">builtins</span><span class="o">|</span>
          <span class="n">builtins</span><span class="o">[</span><span class="ss">:kernel</span><span class="o">]</span> <span class="o">=</span> <span class="no">Set</span><span class="nf">.new</span> <span class="sx">%w(
            or 2bi 2tri while wrapper nip 4dip wrapper? bi*
            callstack&gt;array both? hashcode die dupd callstack
            callstack? 3dup tri@ pick curry build ?execute 3bi prepose
            &gt;boolean if clone eq? tri* ? = swapd 2over 2keep 3keep clear
            2dup when not tuple? dup 2bi* 2tri* call tri-curry object bi@
            do unless* if* loop bi-curry* drop when* assert= retainstack
            assert? -rot execute 2bi@ 2tri@ boa with either? 3drop bi
            curry?  datastack until 3dip over 3curry tri-curry* tri-curry@
            swap and 2nip throw bi-curry (clone) hashcode* compose 2dip if
            3tri unless compose? tuple keep 2curry equal? assert tri 2drop
            most &lt;wrapper&gt; boolean? identity-hashcode identity-tuple?
            null new dip bi-curry@ rot xor identity-tuple boolean
          )</span>

          <span class="n">builtins</span><span class="o">[</span><span class="ss">:assocs</span><span class="o">]</span> <span class="o">=</span> <span class="no">Set</span><span class="nf">.new</span> <span class="sx">%w(
            ?at assoc? assoc-clone-like assoc= delete-at* assoc-partition
            extract-keys new-assoc value? assoc-size map&gt;assoc push-at
            assoc-like key? assoc-intersect assoc-refine update
            assoc-union assoc-combine at* assoc-empty? at+ set-at
            assoc-all? assoc-subset?  assoc-hashcode change-at assoc-each
            assoc-diff zip values value-at rename-at inc-at enum? at cache
            assoc&gt;map &lt;enum&gt; assoc assoc-map enum value-at* assoc-map-as
            &gt;alist assoc-filter-as clear-assoc assoc-stack maybe-set-at
            substitute assoc-filter 2cache delete-at assoc-find keys
            assoc-any? unzip
          )</span>

          <span class="n">builtins</span><span class="o">[</span><span class="ss">:combinators</span><span class="o">]</span> <span class="o">=</span> <span class="no">Set</span><span class="nf">.new</span> <span class="sx">%w(
            case execute-effect no-cond no-case? 3cleave&gt;quot 2cleave
            cond&gt;quot wrong-values? no-cond? cleave&gt;quot no-case case&gt;quot
            3cleave wrong-values to-fixed-point alist&gt;quot case-find
            cond cleave call-effect 2cleave&gt;quot recursive-hashcode
            linear-case-quot spread spread&gt;quot
          )</span>

          <span class="n">builtins</span><span class="o">[</span><span class="ss">:math</span><span class="o">]</span> <span class="o">=</span> <span class="no">Set</span><span class="nf">.new</span> <span class="sx">%w(
            number= if-zero next-power-of-2 each-integer ?1+
            fp-special? imaginary-part unless-zero float&gt;bits number?
            fp-infinity? bignum? fp-snan? denominator fp-bitwise= *
            + power-of-2? - u&gt;= / &gt;= bitand log2-expects-positive &lt;
            log2 &gt; integer? number bits&gt;double 2/ zero? (find-integer)
            bits&gt;float float? shift ratio? even? ratio fp-sign bitnot
            &gt;fixnum complex? /i /f byte-array&gt;bignum when-zero sgn &gt;bignum
            next-float u&lt; u&gt; mod recip rational find-last-integer &gt;float
            (all-integers?) 2^ times integer fixnum? neg fixnum sq bignum
            (each-integer) bit? fp-qnan? find-integer complex &lt;fp-nan&gt;
            real double&gt;bits bitor rem fp-nan-payload all-integers?
            real-part log2-expects-positive? prev-float align unordered?
            float fp-nan? abs bitxor u&lt;= odd? &lt;= /mod rational? &gt;integer
            real? numerator
          )</span>

          <span class="n">builtins</span><span class="o">[</span><span class="ss">:sequences</span><span class="o">]</span> <span class="o">=</span> <span class="no">Set</span><span class="nf">.new</span> <span class="sx">%w(
            member-eq? append assert-sequence= find-last-from
            trim-head-slice clone-like 3sequence assert-sequence? map-as
            last-index-from reversed index-from cut* pad-tail
            remove-eq! concat-as but-last snip trim-tail nths
            nth 2selector sequence slice?  &lt;slice&gt; partition
            remove-nth tail-slice empty? tail* if-empty
            find-from virtual-sequence? member? set-length
            drop-prefix unclip unclip-last-slice iota map-sum
            bounds-error? sequence-hashcode-step selector-for
            accumulate-as map start midpoint@ (accumulate) rest-slice
            prepend fourth sift accumulate! new-sequence follow map! like
            first4 1sequence reverse slice unless-empty padding virtual@
            repetition? set-last index 4sequence max-length set-second
            immutable-sequence first2 first3 replicate-as reduce-index
            unclip-slice supremum suffix! insert-nth trim-tail-slice
            tail 3append short count suffix concat flip filter sum
            immutable? reverse! 2sequence map-integers delete-all start*
            indices snip-slice check-slice sequence?  head map-find
            filter! append-as reduce sequence= halves collapse-slice
            interleave 2map filter-as binary-reduce slice-error? product
            bounds-check? bounds-check harvest immutable virtual-exemplar
            find produce remove pad-head last replicate set-fourth
            remove-eq shorten reversed?  map-find-last 3map-as
            2unclip-slice shorter? 3map find-last head-slice pop* 2map-as
            tail-slice* but-last-slice 2map-reduce iota? collector-for
            accumulate each selector append! new-resizable cut-slice
            each-index head-slice* 2reverse-each sequence-hashcode
            pop set-nth ?nth &lt;flat-slice&gt; second join when-empty
            collector immutable-sequence? &lt;reversed&gt; all? 3append-as
            virtual-sequence subseq? remove-nth! push-either new-like
            length last-index push-if 2all? lengthen assert-sequence
            copy map-reduce move third first 3each tail? set-first prefix
            bounds-error any? &lt;repetition&gt; trim-slice exchange surround
            2reduce cut change-nth min-length set-third produce-as
            push-all head? delete-slice rest sum-lengths 2each head*
            infimum remove! glue slice-error subseq trim replace-slice
            push repetition map-index trim-head unclip-last mismatch
          )</span>

          <span class="n">builtins</span><span class="o">[</span><span class="ss">:namespaces</span><span class="o">]</span> <span class="o">=</span> <span class="no">Set</span><span class="nf">.new</span> <span class="sx">%w(
            global +@ change set-namestack change-global init-namespaces
            on off set-global namespace set with-scope bind with-variable
            inc dec counter initialize namestack get get-global make-assoc
          )</span>

          <span class="n">builtins</span><span class="o">[</span><span class="ss">:arrays</span><span class="o">]</span> <span class="o">=</span> <span class="no">Set</span><span class="nf">.new</span> <span class="sx">%w(
            &lt;array&gt; 2array 3array pair &gt;array 1array 4array pair?
            array resize-array array?
          )</span>

          <span class="n">builtins</span><span class="o">[</span><span class="ss">:io</span><span class="o">]</span> <span class="o">=</span> <span class="no">Set</span><span class="nf">.new</span> <span class="sx">%w(
            +character+ bad-seek-type? readln each-morsel
            stream-seek read print with-output-stream contents
            write1 stream-write1 stream-copy stream-element-type
            with-input-stream stream-print stream-read stream-contents
            stream-tell tell-output bl seek-output bad-seek-type nl
            stream-nl write flush stream-lines +byte+ stream-flush
            read1 seek-absolute? stream-read1 lines stream-readln
            stream-read-until each-line seek-end with-output-stream*
            seek-absolute with-streams seek-input seek-relative?
            input-stream stream-write read-partial seek-end?
            seek-relative error-stream read-until with-input-stream*
            with-streams* tell-input each-block output-stream
            stream-read-partial each-stream-block each-stream-line
          )</span>

          <span class="n">builtins</span><span class="o">[</span><span class="ss">:strings</span><span class="o">]</span> <span class="o">=</span> <span class="no">Set</span><span class="nf">.new</span> <span class="sx">%w(
            resize-string &gt;string &lt;string&gt; 1string string string?
          )</span>

          <span class="n">builtins</span><span class="o">[</span><span class="ss">:vectors</span><span class="o">]</span> <span class="o">=</span> <span class="no">Set</span><span class="nf">.new</span> <span class="sx">%w(
            with-return restarts return-continuation with-datastack
            recover rethrow-restarts &lt;restart&gt; ifcc set-catchstack
            &gt;continuation&lt; cleanup ignore-errors restart?
            compute-restarts attempt-all-error error-thread
            continue &lt;continuation&gt; attempt-all-error? condition?
            &lt;condition&gt; throw-restarts error catchstack continue-with
            thread-error-hook continuation rethrow callcc1
            error-continuation callcc0 attempt-all condition
            continuation? restart return
          )</span>

          <span class="n">builtins</span><span class="o">[</span><span class="ss">:continuations</span><span class="o">]</span> <span class="o">=</span> <span class="no">Set</span><span class="nf">.new</span> <span class="sx">%w(
            with-return restarts return-continuation with-datastack
            recover rethrow-restarts &lt;restart&gt; ifcc set-catchstack
            &gt;continuation&lt; cleanup ignore-errors restart?
            compute-restarts attempt-all-error error-thread
            continue &lt;continuation&gt; attempt-all-error? condition?
            &lt;condition&gt; throw-restarts error catchstack continue-with
            thread-error-hook continuation rethrow callcc1
            error-continuation callcc0 attempt-all condition
            continuation? restart return
          )</span>
        <span class="k">end</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:root</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">/\s+/m</span><span class="p">,</span> <span class="s1">&#39;Text&#39;</span>

        <span class="n">rule</span> <span class="sr">/(:|::|MACRO:|MEMO:|GENERIC:|HELP:)(\s+)(\S+)/m</span> <span class="k">do</span>
          <span class="n">group</span> <span class="s1">&#39;Keyword&#39;</span><span class="p">;</span> <span class="n">group</span> <span class="s1">&#39;Text&#39;</span>
          <span class="n">group</span> <span class="s1">&#39;Name.Function&#39;</span>
        <span class="k">end</span>

        <span class="n">rule</span> <span class="sr">/(M:|HOOK:|GENERIC#)(\s+)(\S+)(\s+)(\S+)/m</span> <span class="k">do</span>
          <span class="n">group</span> <span class="s1">&#39;Keyword&#39;</span><span class="p">;</span> <span class="n">group</span> <span class="s1">&#39;Text&#39;</span>
          <span class="n">group</span> <span class="s1">&#39;Name.Class&#39;</span><span class="p">;</span> <span class="n">group</span> <span class="s1">&#39;Text&#39;</span>
          <span class="n">group</span> <span class="s1">&#39;Name.Function&#39;</span>
        <span class="k">end</span>

        <span class="n">rule</span> <span class="sr">/\((?=\s)/</span><span class="p">,</span> <span class="s1">&#39;Name.Function&#39;</span><span class="p">,</span> <span class="ss">:stack_effect</span>
        <span class="n">rule</span> <span class="sr">/;(?=\s)/</span><span class="p">,</span> <span class="s1">&#39;Keyword&#39;</span>

        <span class="n">rule</span> <span class="sr">/(USING:)((?:\s|\\\s)+)/m</span> <span class="k">do</span>
          <span class="n">group</span> <span class="s1">&#39;Keyword.Namespace&#39;</span><span class="p">;</span> <span class="n">group</span> <span class="s1">&#39;Text&#39;</span>
          <span class="n">push</span> <span class="ss">:import</span>
        <span class="k">end</span>

        <span class="n">rule</span> <span class="sr">/(IN:|USE:|UNUSE:|QUALIFIED:|QUALIFIED-WITH:)(\s+)(\S+)/m</span> <span class="k">do</span>
          <span class="n">group</span> <span class="s1">&#39;Keyword.Namespace&#39;</span><span class="p">;</span> <span class="n">group</span> <span class="s1">&#39;Text&#39;</span><span class="p">;</span> <span class="n">group</span> <span class="s1">&#39;Name.Namespace&#39;</span>
        <span class="k">end</span>

        <span class="n">rule</span> <span class="sr">/(FROM:|EXCLUDE:)(\s+)(\S+)(\s+)(=&gt;)/m</span> <span class="k">do</span>
          <span class="n">group</span> <span class="s1">&#39;Keyword.Namespace&#39;</span><span class="p">;</span> <span class="n">group</span> <span class="s1">&#39;Text&#39;</span>
          <span class="n">group</span> <span class="s1">&#39;Name.Namespace&#39;</span><span class="p">;</span> <span class="n">group</span> <span class="s1">&#39;Text&#39;</span>
          <span class="n">group</span> <span class="s1">&#39;Punctuation&#39;</span>
        <span class="k">end</span>

        <span class="n">rule</span> <span class="sr">/(?:ALIAS|DEFER|FORGET|POSTPONE):/</span><span class="p">,</span> <span class="s1">&#39;Keyword.Namespace&#39;</span>

        <span class="n">rule</span> <span class="sr">/(TUPLE:)(\s+)(\S+)(\s+)(&lt;)(\s+)(\S+)/m</span> <span class="k">do</span>
          <span class="n">group</span> <span class="s1">&#39;Keyword&#39;</span><span class="p">;</span> <span class="n">group</span> <span class="s1">&#39;Text&#39;</span>
          <span class="n">group</span> <span class="s1">&#39;Name.Class&#39;</span><span class="p">;</span> <span class="n">group</span> <span class="s1">&#39;Text&#39;</span>
          <span class="n">group</span> <span class="s1">&#39;Punctuation&#39;</span><span class="p">;</span> <span class="n">group</span> <span class="s1">&#39;Text&#39;</span>
          <span class="n">group</span> <span class="s1">&#39;Name.Class&#39;</span>
          <span class="n">push</span> <span class="ss">:slots</span>
        <span class="k">end</span>

        <span class="n">rule</span> <span class="sr">/(TUPLE:)(\s+)(\S+)/m</span> <span class="k">do</span>
          <span class="n">group</span> <span class="s1">&#39;Keyword&#39;</span><span class="p">;</span> <span class="n">group</span> <span class="s1">&#39;Text&#39;</span><span class="p">;</span> <span class="n">group</span> <span class="s1">&#39;Name.Class&#39;</span>
          <span class="n">push</span> <span class="ss">:slots</span>
        <span class="k">end</span>

        <span class="n">rule</span> <span class="sr">/(UNION:|INTERSECTION:)(\s+)(\S+)/m</span> <span class="k">do</span>
          <span class="n">group</span> <span class="s1">&#39;Keyword&#39;</span><span class="p">;</span> <span class="n">group</span> <span class="s1">&#39;Text&#39;</span><span class="p">;</span> <span class="n">group</span> <span class="s1">&#39;Name.Class&#39;</span>
        <span class="k">end</span>

        <span class="n">rule</span> <span class="sr">/(PREDICATE:)(\s+)(\S+)(\s+)(&lt;)(\s+)(\S+)/m</span> <span class="k">do</span>
          <span class="n">group</span> <span class="s1">&#39;Keyword&#39;</span><span class="p">;</span> <span class="n">group</span> <span class="s1">&#39;Text&#39;</span>
          <span class="n">group</span> <span class="s1">&#39;Name.Class&#39;</span><span class="p">;</span> <span class="n">group</span> <span class="s1">&#39;Text&#39;</span>
          <span class="n">group</span> <span class="s1">&#39;Punctuation&#39;</span><span class="p">;</span> <span class="n">group</span> <span class="s1">&#39;Text&#39;</span>
          <span class="n">group</span> <span class="s1">&#39;Name.Class&#39;</span>
        <span class="k">end</span>

        <span class="n">rule</span> <span class="sr">/(C:)(\s+)(\S+)(\s+)(\S+)/m</span> <span class="k">do</span>
          <span class="n">group</span> <span class="s1">&#39;Keyword&#39;</span><span class="p">;</span> <span class="n">group</span> <span class="s1">&#39;Text&#39;</span>
          <span class="n">group</span> <span class="s1">&#39;Name.Function&#39;</span><span class="p">;</span> <span class="n">group</span> <span class="s1">&#39;Text&#39;</span>
          <span class="n">group</span> <span class="s1">&#39;Name.Class&#39;</span>
        <span class="k">end</span>

        <span class="n">rule</span> <span class="sr">%r(
          (INSTANCE|SLOT|MIXIN|SINGLETONS?|CONSTANT|SYMBOLS?|ERROR|SYNTAX
           |ALIEN|TYPEDEF|FUNCTION|STRUCT):
        )x</span><span class="p">,</span> <span class="s1">&#39;Keyword&#39;</span>

        <span class="n">rule</span> <span class="sr">/(?:&lt;PRIVATE|PRIVATE&gt;)/</span><span class="p">,</span> <span class="s1">&#39;Keyword.Namespace&#39;</span>

        <span class="n">rule</span> <span class="sr">/(MAIN:)(\s+)(\S+)/</span> <span class="k">do</span>
          <span class="n">group</span> <span class="s1">&#39;Keyword.Namespace&#39;</span><span class="p">;</span> <span class="n">group</span> <span class="s1">&#39;Text&#39;</span><span class="p">;</span> <span class="n">group</span> <span class="s1">&#39;Name.Function&#39;</span>
        <span class="k">end</span>

        <span class="c1"># strings</span>
        <span class="n">rule</span> <span class="sr">/&quot;&quot;&quot;\s+.*?\s+&quot;&quot;&quot;/</span><span class="p">,</span> <span class="s1">&#39;Literal.String&#39;</span>
        <span class="n">rule</span> <span class="sr">/&quot;(\\.|[^\\])*?&quot;/</span><span class="p">,</span> <span class="s1">&#39;Literal.String&#39;</span>
        <span class="n">rule</span> <span class="sr">/(CHAR:)(\s+)(\\[\\abfnrstv]*|\S)(?=\s)/</span><span class="p">,</span> <span class="s1">&#39;Literal.String.Char&#39;</span>

        <span class="c1"># comments</span>
        <span class="n">rule</span> <span class="sr">/!\s+.*$/</span><span class="p">,</span> <span class="s1">&#39;Comment&#39;</span>
        <span class="n">rule</span> <span class="sr">/#!\s+.*$/</span><span class="p">,</span> <span class="s1">&#39;Comment&#39;</span>

        <span class="c1"># booleans</span>
        <span class="n">rule</span> <span class="sr">/[tf](?=\s)/</span><span class="p">,</span> <span class="s1">&#39;Name.Constant&#39;</span>

        <span class="c1"># numbers</span>
        <span class="n">rule</span> <span class="sr">/-?\d+\.\d+(?=\s)/</span><span class="p">,</span> <span class="s1">&#39;Literal.Number.Float&#39;</span>
        <span class="n">rule</span> <span class="sr">/-?\d+(?=\s)/</span><span class="p">,</span> <span class="s1">&#39;Literal.Number.Integer&#39;</span>

        <span class="n">rule</span> <span class="sr">/HEX:\s+[a-fA-F\d]+(?=\s)/m</span><span class="p">,</span> <span class="s1">&#39;Literal.Number.Hex&#39;</span>
        <span class="n">rule</span> <span class="sr">/BIN:\s+[01]+(?=\s)/</span><span class="p">,</span> <span class="s1">&#39;Literal.Number.Bin&#39;</span>
        <span class="n">rule</span> <span class="sr">/OCT:\s+[0-7]+(?=\s)/</span><span class="p">,</span> <span class="s1">&#39;Literal.Number.Oct&#39;</span>

        <span class="n">rule</span> <span class="sr">%r([-+/*=&lt;&gt;^](?=</span><span class="se">\s</span><span class="sr">))</span><span class="p">,</span> <span class="s1">&#39;Operator&#39;</span>

        <span class="n">rule</span> <span class="sr">/(?:deprecated|final|foldable|flushable|inline|recursive)(?=\s)/</span><span class="p">,</span>
          <span class="s1">&#39;Keyword&#39;</span>

        <span class="c1"># words, to be postprocessed for builtins and things</span>
        <span class="n">rule</span> <span class="sr">/\S+/</span><span class="p">,</span> <span class="s1">&#39;Postprocess.Word&#39;</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:stack_effect</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">/\s+/</span><span class="p">,</span> <span class="s1">&#39;Text&#39;</span>
        <span class="n">rule</span> <span class="sr">/\(/</span><span class="p">,</span> <span class="s1">&#39;Name.Function&#39;</span><span class="p">,</span> <span class="ss">:stack_effect</span>
        <span class="n">rule</span> <span class="sr">/\)/</span><span class="p">,</span> <span class="s1">&#39;Name.Function&#39;</span><span class="p">,</span> <span class="ss">:pop!</span>

        <span class="n">rule</span> <span class="sr">/--/</span><span class="p">,</span> <span class="s1">&#39;Name.Function&#39;</span>
        <span class="n">rule</span> <span class="sr">/\S+/</span><span class="p">,</span> <span class="s1">&#39;Name.Variable&#39;</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:slots</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">/\s+/</span><span class="p">,</span> <span class="s1">&#39;Text&#39;</span>
        <span class="n">rule</span> <span class="sr">/;(?=\s)/</span><span class="p">,</span> <span class="s1">&#39;Keyword&#39;</span><span class="p">,</span> <span class="ss">:pop!</span>
        <span class="n">rule</span> <span class="sr">/\S+/</span><span class="p">,</span> <span class="s1">&#39;Name.Variable&#39;</span>
      <span class="k">end</span>

      <span class="n">state</span> <span class="ss">:import</span> <span class="k">do</span>
        <span class="n">rule</span> <span class="sr">/;(?=\s)/</span><span class="p">,</span> <span class="s1">&#39;Keyword&#39;</span><span class="p">,</span> <span class="ss">:pop!</span>
        <span class="n">rule</span> <span class="sr">/\s+/</span><span class="p">,</span> <span class="s1">&#39;Text&#39;</span>
        <span class="n">rule</span> <span class="sr">/\S+/</span><span class="p">,</span> <span class="s1">&#39;Name.Namespace&#39;</span>
      <span class="k">end</span>

      <span class="n">postprocess</span> <span class="s1">&#39;Postprocess.Word&#39;</span> <span class="k">do</span> <span class="o">|</span><span class="n">tok</span><span class="p">,</span> <span class="n">val</span><span class="o">|</span>
        <span class="n">tok</span> <span class="o">=</span> <span class="k">if</span> <span class="nb">self</span><span class="nf">.class.builtins.values.any?</span> <span class="p">{</span> <span class="o">|</span><span class="n">b</span><span class="o">|</span> <span class="n">b</span><span class="nf">.include?</span> <span class="n">val</span> <span class="p">}</span>
          <span class="s1">&#39;Name.Builtin&#39;</span>
        <span class="k">else</span>
          <span class="s1">&#39;Name&#39;</span>
        <span class="k">end</span>

        <span class="n">token</span> <span class="n">tok</span><span class="p">,</span> <span class="n">val</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>